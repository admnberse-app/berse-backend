generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AnnouncementAnalytic {
  id             String       @id @default(cuid())
  announcementId String
  userId         String?
  viewed         Boolean      @default(false)
  viewedAt       DateTime?
  clicked        Boolean      @default(false)
  clickedAt      DateTime?
  dismissed      Boolean      @default(false)
  dismissedAt    DateTime?
  viewedFrom     String?
  deviceInfo     Json?
  createdAt      DateTime     @default(now())
  announcements  Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)

  @@index([announcementId, viewed])
  @@index([userId])
  @@map("announcement_analytics")
}

model Announcement {
  id                String                 @id @default(cuid())
  title             String
  content           String
  excerpt           String?
  imageUrl          String?
  thumbnailUrl      String?
  videoUrl          String?
  priority          AnnouncementPriority   @default(NORMAL)
  displayType       String                 @default("banner")
  targetAudience    String                 @default("all")
  targetCountries   String[]               @default([])
  targetUserSegment String[]               @default([])
  minAppVersion     String?
  ctaText           String?
  ctaUrl            String?
  ctaAction         String?
  publishedAt       DateTime?
  expiresAt         DateTime?
  isActive          Boolean                @default(true)
  isPinned          Boolean                @default(false)
  isDismissible     Boolean                @default(true)
  viewCount         Int                    @default(0)
  clickCount        Int                    @default(0)
  createdBy         String?
  tags              String[]               @default([])
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt
  analytics         AnnouncementAnalytic[]

  @@index([expiresAt])
  @@index([isActive, publishedAt])
  @@index([isPinned, isActive])
  @@index([priority, isActive])
  @@map("announcements")
}

model AppConfig {
  id          String   @id @default(cuid())
  configKey   String   @unique
  configValue String
  dataType    String   @default("string")
  category    String   @default("general")
  description String?
  isPublic    Boolean  @default(false)
  isEditable  Boolean  @default(true)
  updatedBy   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category, isPublic])
  @@index([configKey])
  @@map("app_configs")
}

model AppNoticeDismissal {
  id          String    @id @default(cuid())
  noticeId    String
  userId      String
  dismissedAt DateTime  @default(now())
  app_notices AppNotice @relation(fields: [noticeId], references: [id], onDelete: Cascade)

  @@unique([noticeId, userId])
  @@index([userId])
  @@map("app_notice_dismissals")
}

model AppNotice {
  id                 String               @id @default(cuid())
  noticeType         AppNoticeType
  title              String
  message            String
  icon               String?
  displayLocation    String[]             @default(["home"])
  displayStyle       String               @default("banner")
  priority           Int                  @default(0)
  isDismissible      Boolean              @default(true)
  autoDismiss        Boolean              @default(false)
  autoDismissSeconds Int?
  targetAudience     String               @default("all")
  targetUserIds      String[]             @default([])
  targetSegments     String[]             @default([])
  targetCountries    String[]             @default([])
  minAppVersion      String?
  ctaText            String?
  ctaAction          String?
  ctaUrl             String?
  startDate          DateTime             @default(now())
  endDate            DateTime?
  isActive           Boolean              @default(true)
  impressionCount    Int                  @default(0)
  dismissCount       Int                  @default(0)
  clickCount         Int                  @default(0)
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  dismissals         AppNoticeDismissal[]

  @@index([isActive, startDate, endDate])
  @@index([noticeType, isActive])
  @@index([priority, isActive])
  @@map("app_notices")
}

model AppVersion {
  id                  String      @id @default(cuid())
  versionNumber       String
  versionCode         Int
  platform            AppPlatform
  releaseDate         DateTime
  releaseNotes        String
  releaseType         String      @default("stable")
  isForceUpdate       Boolean     @default(false)
  minSupportedVersion String?
  isActive            Boolean     @default(true)
  isCurrent           Boolean     @default(false)
  downloadUrl         String?
  storeUrl            String?
  features            Json?
  bugFixes            Json?
  improvements        Json?
  deprecations        Json?
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt

  @@unique([versionNumber, platform])
  @@index([platform, isActive])
  @@index([platform, isCurrent])
  @@index([releaseDate])
  @@map("app_versions")
}

model AuthIdentity {
  id          String   @id @default(cuid())
  userId      String
  provider    String
  providerUid String
  email       String?
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerUid])
  @@index([userId])
  @@map("auth_identities")
}

model Badge {
  id          String    @id @default(cuid())
  type        BadgeType @unique
  name        String
  description String
  criteria    String // Human-readable description
  imageUrl    String?
  isActive    Boolean   @default(true) // Can disable badges without deleting

  // Dynamic criteria configuration stored as JSON
  criteriaConfig Json? // { "type": "event_attendance", "eventType": "SPORTS", "count": 5 }

  // Progression tracking
  requiredCount Int @default(1) // How many actions needed

  // Metadata for display and categorization
  category String? // "Social", "Events", "Community", etc.
  tier     String? // "Bronze", "Silver", "Gold" for progression
  points   Int     @default(0) // Optional: points awarded for earning this badge

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userBadges UserBadge[]

  @@index([isActive])
  @@index([category])
  @@map("badges")
}

model CardGameFeedback {
  id                String           @id @default(cuid())
  userId            String
  topicId           String
  sessionNumber     Int
  questionId        String
  rating            Int
  comment           String?
  topicTitle        String? // NEW: Display name of topic
  questionText      String? // NEW: Actual question text
  isHelpful         Boolean          @default(true) // NEW: Was question helpful?
  upvoteCount       Int              @default(0)
  // NEW TIMING FIELDS
  timeSpentSeconds  Int? // time spent on this question
  questionViewedAt  DateTime?
  answerStartedAt   DateTime?
  answerSubmittedAt DateTime?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  topic             CardGameTopic?   @relation(fields: [topicId], references: [id])
  cardGameReplies   CardGameReply[]
  cardGameUpvotes   CardGameUpvote[]

  @@index([questionId])
  @@index([topicId])
  @@index([userId])
  @@index([upvoteCount])
  @@index([userId, topicId, sessionNumber])
  @@map("card_game_feedbacks")
}

model CardGameReply {
  id                   String                @id @default(cuid())
  userId               String
  feedbackId           String
  parentReplyId        String?
  text                 String
  upvoteCount          Int                   @default(0)
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  cardGameFeedbacks    CardGameFeedback      @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentReply          CardGameReply?        @relation("ReplyToReply", fields: [parentReplyId], references: [id], onDelete: Cascade)
  childReplies         CardGameReply[]       @relation("ReplyToReply")
  cardGameReplyUpvotes CardGameReplyUpvote[]

  @@index([feedbackId])
  @@index([userId])
  @@index([parentReplyId])
  @@index([upvoteCount])
  @@map("card_game_replies")
}

model CardGameReplyUpvote {
  id        String        @id @default(cuid())
  userId    String
  replyId   String
  createdAt DateTime      @default(now())
  reply     CardGameReply @relation(fields: [replyId], references: [id], onDelete: Cascade)
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, replyId])
  @@index([replyId])
  @@index([userId])
  @@map("card_game_reply_upvotes")
}

model CardGameStat {
  id            String   @id @default(cuid())
  topicId       String   @unique
  totalSessions Int      @default(0)
  averageRating Float    @default(0)
  totalFeedback Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([topicId])
  @@map("card_game_stats")
}

model CardGameUpvote {
  id                String           @id @default(cuid())
  userId            String
  feedbackId        String
  createdAt         DateTime         @default(now())
  cardGameFeedbacks CardGameFeedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, feedbackId])
  @@index([feedbackId])
  @@index([userId])
  @@map("card_game_upvotes")
}

model CardGameTopic {
  id            String             @id // e.g., "slowdown"
  title         String
  description   String?
  gradient      String? // CSS gradient string for UI
  totalSessions Int                @default(0)
  isActive      Boolean            @default(true)
  displayOrder  Int                @default(0)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  questions     CardGameQuestion[]
  feedbacks     CardGameFeedback[]
  sessions      CardGameSession[]

  @@index([isActive, displayOrder])
  @@map("card_game_topics")
}

model CardGameQuestion {
  id            String        @id @default(cuid())
  topicId       String
  sessionNumber Int
  questionOrder Int // Position in session (1-10)
  questionText  String
  isActive      Boolean       @default(true)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  topic         CardGameTopic @relation(fields: [topicId], references: [id], onDelete: Cascade)

  @@unique([topicId, sessionNumber, questionOrder])
  @@index([topicId])
  @@index([topicId, sessionNumber])
  @@map("card_game_questions")
}

model CardGameSession {
  id                String        @id @default(cuid())
  userId            String
  topicId           String
  sessionNumber     Int
  startedAt         DateTime      @default(now())
  completedAt       DateTime?
  totalQuestions    Int
  questionsAnswered Int           @default(0)
  averageRating     Float?
  // NEW FIELDS
  totalDuration     Int? // seconds
  lastActivityAt    DateTime      @default(now())
  devicePlatform    String? // "mobile" | "web"
  deviceOS          String? // "iOS" | "Android" | "Web"
  appVersion        String?
  status            String        @default("in-progress") // "in-progress" | "completed" | "abandoned"
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  topic             CardGameTopic @relation(fields: [topicId], references: [id], onDelete: Cascade)

  @@unique([userId, topicId, sessionNumber])
  @@index([userId])
  @@index([topicId])
  @@index([userId, completedAt])
  @@index([userId, status])
  @@index([topicId, completedAt])
  @@map("card_game_sessions")
}

model Community {
  id               String                @id @default(cuid())
  name             String                @unique
  description      String?
  logoUrl          String? // Community logo image
  coverImageUrl    String? // Community cover/banner image
  category         String? // @deprecated - Use interests array instead
  interests        String[]              @default([]) // Array of interest values matching profile metadata
  city             String? // City name for filtering
  country          String? // Country name for filtering
  latitude         Float? // For proximity search
  longitude        Float? // For proximity search
  isVerified       Boolean               @default(false)
  requiresApproval Boolean               @default(true) // Whether new members need approval to join
  guidelines       String? // Community rules and guidelines (markdown supported)
  socialLinks      Json? // Social media links: {instagram, facebook, linkedin, twitter, youtube, tiktok}
  websiteUrl       String? // Community website URL
  contactEmail     String? // Community contact email
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  deletedAt        DateTime?
  createdById      String
  user             User                  @relation(fields: [createdById], references: [id], onDelete: Cascade)
  communityMembers CommunityMember[]
  events           Event[]
  vouchOffers      CommunityVouchOffer[]

  @@index([category])
  @@index([createdAt])
  @@index([name])
  @@index([city])
  @@index([country])
  @@index([latitude, longitude])
  @@index([deletedAt])
  @@map("communities")
}

model CommunityVouchOffer {
  id                  String           @id @default(cuid())
  userId              String
  communityId         String
  eligibilityReason   String // e.g. "5+ events attended, 90+ days membership, zero negative feedback"
  status              VouchOfferStatus @default(PENDING)
  eventsAttended      Int              @default(0)
  membershipDays      Int              @default(0)
  hasNegativeFeedback Boolean          @default(false)
  offerMetadata       Json? // Additional eligibility details
  createdAt           DateTime         @default(now())
  expiresAt           DateTime // Auto-set to 30 days from creation
  acceptedAt          DateTime?
  rejectedAt          DateTime?
  vouchId             String?          @unique // Reference to created vouch if accepted
  user                User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  community           Community        @relation(fields: [communityId], references: [id], onDelete: Cascade)

  @@unique([userId, communityId, status])
  @@index([userId])
  @@index([communityId])
  @@index([status])
  @@index([expiresAt])
  @@index([createdAt])
  @@map("community_vouch_offers")
}

model CommunityMember {
  id          String        @id @default(cuid())
  role        CommunityRole @default(MEMBER)
  joinedAt    DateTime      @default(now())
  isApproved  Boolean       @default(false)
  joinMessage String?
  userId      String
  communityId String
  communities Community     @relation(fields: [communityId], references: [id], onDelete: Cascade)
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, communityId])
  @@index([communityId])
  @@index([role])
  @@index([userId])
  @@map("community_members")
}

model ConnectionReview {
  id                                         String         @id @default(cuid())
  connectionId                               String
  reviewerId                                 String
  revieweeId                                 String
  rating                                     Int
  review                                     String?
  reviewType                                 String         @default("general")
  isPublic                                   Boolean        @default(true)
  isFeatured                                 Boolean        @default(false)
  isVerified                                 Boolean        @default(false)
  verificationSource                         String?
  helpfulCount                               Int            @default(0)
  createdAt                                  DateTime       @default(now())
  updatedAt                                  DateTime       @updatedAt
  user_connections                           UserConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  users_connection_reviews_revieweeIdTousers User           @relation("connection_reviews_revieweeIdTousers", fields: [revieweeId], references: [id], onDelete: Cascade)
  users_connection_reviews_reviewerIdTousers User           @relation("connection_reviews_reviewerIdTousers", fields: [reviewerId], references: [id], onDelete: Cascade)

  @@unique([connectionId, reviewerId])
  @@index([connectionId])
  @@index([createdAt])
  @@index([isPublic, isFeatured])
  @@index([rating])
  @@index([revieweeId])
  @@index([reviewerId])
  @@map("connection_reviews")
}

model ConnectionStat {
  userId                  String   @id
  totalConnections        Int      @default(0)
  pendingRequests         Int      @default(0)
  sentRequests            Int      @default(0)
  professionalConnections Int      @default(0)
  friendConnections       Int      @default(0)
  familyConnections       Int      @default(0)
  mentorConnections       Int      @default(0)
  travelConnections       Int      @default(0)
  communityConnections    Int      @default(0)
  averageRating           Float?
  highestRating           Float?
  totalReviewsReceived    Int      @default(0)
  totalReviewsGiven       Int      @default(0)
  totalMutualFriends      Int      @default(0)
  trustChainDepth         Int      @default(1)
  connectionQuality       Float    @default(0.0)
  lastCalculatedAt        DateTime @default(now())
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt
  users                   User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([averageRating])
  @@index([connectionQuality])
  @@index([totalConnections])
  @@map("connection_stats")
}

model DeviceRegistration {
  id                String   @id @default(cuid())
  userId            String
  deviceFingerprint String
  deviceName        String?
  deviceInfo        Json
  isTrusted         Boolean  @default(false)
  lastSeenAt        DateTime @default(now())
  createdAt         DateTime @default(now())
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceFingerprint])
  @@index([userId])
  @@map("device_registrations")
}

model EmailVerificationToken {
  id         String    @id @default(cuid())
  userId     String
  email      String
  token      String    @unique
  expiresAt  DateTime
  verifiedAt DateTime?
  createdAt  DateTime  @default(now())
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@map("email_verification_tokens")
}

model EmailChangeRequest {
  id        String   @id @default(cuid())
  userId    String
  oldEmail  String
  newEmail  String
  token     String   @unique
  expiresAt DateTime
  verified  Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("email_change_requests")
}

model EventParticipant {
  id           String                 @id @default(cuid())
  userId       String
  eventId      String
  status       EventParticipantStatus @default(REGISTERED)
  qrCode       String                 @unique
  checkedInAt  DateTime?
  canceledAt   DateTime?
  createdAt    DateTime               @default(now())
  updatedAt    DateTime               @updatedAt
  events       Event                  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user         User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventTickets EventTicket[]

  @@unique([userId, eventId])
  @@index([eventId])
  @@index([userId])
  @@index([status])
  @@index([checkedInAt])
  @@index([createdAt])
  @@map("event_participants")
}

model EventTicketTier {
  id             String        @id @default(cuid())
  eventId        String
  tierName       String
  description    String?
  price          Float
  currency       String        @default("MYR")
  totalQuantity  Int?
  soldQuantity   Int           @default(0)
  minPurchase    Int           @default(1)
  maxPurchase    Int           @default(10)
  availableFrom  DateTime?
  availableUntil DateTime?
  displayOrder   Int           @default(0)
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  events         Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventTickets   EventTicket[]

  @@index([availableFrom, availableUntil])
  @@index([eventId, isActive])
  @@map("event_ticket_tiers")
}

model EventTicket {
  id                   String              @id @default(cuid())
  eventId              String
  userId               String
  participantId        String
  ticketTierId         String?
  ticketType           String              @default("GENERAL")
  price                Float
  currency             String              @default("MYR")
  status               EventTicketStatus   @default(PENDING)
  paymentTransactionId String?
  paymentStatus        PaymentStatus       @default(PENDING)
  ticketNumber         String              @unique
  purchasedAt          DateTime            @default(now())
  canceledAt           DateTime?
  refundedAt           DateTime?
  attendeeName         String?
  attendeeEmail        String?
  attendeePhone        String?
  events               Event               @relation(fields: [eventId], references: [id], onDelete: Cascade)
  participant          EventParticipant    @relation(fields: [participantId], references: [id], onDelete: Cascade)
  paymentTransactions  PaymentTransaction? @relation(fields: [paymentTransactionId], references: [id])
  tier                 EventTicketTier?    @relation(fields: [ticketTierId], references: [id])
  user                 User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, ticketNumber])
  @@index([eventId])
  @@index([participantId])
  @@index([paymentTransactionId])
  @@index([purchasedAt])
  @@index([status])
  @@index([ticketNumber])
  @@index([ticketTierId])
  @@index([userId])
  @@index([userId, status])
  @@map("event_tickets")
}

model Event {
  id                String             @id @default(cuid())
  title             String
  description       String?
  type              EventType
  date              DateTime // Legacy field, kept for backward compatibility
  startDate         DateTime? // Event start date
  endDate           DateTime? // Event end date
  startTime         String? // Event start time (HH:mm format)
  endTime           String? // Event end time (HH:mm format)
  location          String
  city              String? // City name for filtering
  country           String? // Country name for filtering
  latitude          Float? // For proximity search
  longitude         Float? // For proximity search
  mapLink           String?
  maxAttendees      Int?
  notes             String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  deletedAt         DateTime?
  hostId            String
  communityId       String?
  currency          String             @default("MYR")
  hostType          EventHostType      @default(PERSONAL)
  images            String[]           @default([])
  isFree            Boolean            @default(true)
  status            EventStatus        @default(DRAFT)
  eventParticipants EventParticipant[]
  tier              EventTicketTier[]
  eventTickets      EventTicket[]
  trust_moments     TrustMoment[]
  communities       Community?         @relation(fields: [communityId], references: [id])
  user              User               @relation(fields: [hostId], references: [id], onDelete: Cascade)

  @@index([communityId, date])
  @@index([communityId])
  @@index([createdAt])
  @@index([date])
  @@index([hostId, date])
  @@index([hostId])
  @@index([hostType])
  @@index([isFree])
  @@index([location])
  @@index([city])
  @@index([country])
  @@index([latitude, longitude])
  @@index([status])
  @@index([type, date])
  @@index([type])
  @@index([deletedAt])
  @@map("events")
}

model FaqAnalytic {
  id            String    @id @default(cuid())
  faqId         String
  userId        String?
  viewed        Boolean   @default(false)
  viewedAt      DateTime?
  markedHelpful Boolean?
  markedAt      DateTime?
  searchQuery   String?
  viewedFrom    String?
  createdAt     DateTime  @default(now())
  faqs          Faq       @relation(fields: [faqId], references: [id], onDelete: Cascade)

  @@index([faqId, viewed])
  @@index([userId])
  @@map("faq_analytics")
}

model FaqCategory {
  id           String  @id @default(cuid())
  name         String
  description  String?
  icon         String?
  displayOrder Int     @default(0)
  isActive     Boolean @default(true)
  faqs         Faq[]

  @@index([displayOrder, isActive])
  @@map("faq_categories")
}

model Faq {
  id                String        @id @default(cuid())
  categoryId        String?
  question          String
  answer            String
  displayOrder      Int           @default(0)
  tags              String[]      @default([])
  isActive          Boolean       @default(true)
  isFeatured        Boolean       @default(false)
  viewCount         Int           @default(0)
  helpfulCount      Int           @default(0)
  notHelpfulCount   Int           @default(0)
  relatedFaqIds     String[]      @default([])
  relatedArticleIds String[]      @default([])
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  analytics         FaqAnalytic[]
  category          FaqCategory?  @relation(fields: [categoryId], references: [id])

  @@index([categoryId, isActive])
  @@index([displayOrder])
  @@index([isFeatured, isActive])
  @@map("faqs")
}

model FeatureFlagAnalytic {
  id            String      @id @default(cuid())
  featureFlagId String
  userId        String?
  wasEnabled    Boolean
  evaluatedAt   DateTime    @default(now())
  variant       String?
  userSegment   String?
  platform      String?
  appVersion    String?
  featureUsed   Boolean     @default(false)
  usedAt        DateTime?
  usageCount    Int         @default(0)
  feature_flags FeatureFlag @relation(fields: [featureFlagId], references: [id], onDelete: Cascade)

  @@index([evaluatedAt])
  @@index([featureFlagId, wasEnabled])
  @@index([userId])
  @@map("feature_flag_analytics")
}

model FeatureFlag {
  id                 String                @id @default(cuid())
  featureKey         String                @unique
  featureName        String
  description        String?
  isEnabled          Boolean               @default(false)
  isGlobal           Boolean               @default(false)
  rolloutPercentage  Float                 @default(0.0)
  rolloutStrategy    String                @default("percentage")
  targetUserIds      String[]              @default([])
  targetSegments     String[]              @default([])
  targetCountries    String[]              @default([])
  targetPlatforms    String[]              @default([])
  minAppVersion      String?
  maxAppVersion      String?
  isABTest           Boolean               @default(false)
  abTestVariant      String?
  abTestMetrics      Json?
  enabledAt          DateTime?
  disabledAt         DateTime?
  scheduledEnableAt  DateTime?
  scheduledDisableAt DateTime?
  createdBy          String?
  tags               String[]              @default([])
  dependencies       String[]              @default([])
  createdAt          DateTime              @default(now())
  updatedAt          DateTime              @updatedAt
  analytics          FeatureFlagAnalytic[]

  @@index([featureKey, isEnabled])
  @@index([isEnabled, isGlobal])
  @@map("feature_flags")
}

model FeatureUsage {
  id             String   @id @default(cuid())
  userId         String
  subscriptionId String?
  featureCode    String
  entityType     String
  entityId       String?
  usedAt         DateTime @default(now())
  periodStart    DateTime
  periodEnd      DateTime
  metadata       Json?
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([periodStart, periodEnd])
  @@index([subscriptionId, featureCode])
  @@index([usedAt])
  @@index([userId, featureCode])
  @@map("feature_usage")
}

model HelpArticleAnalytic {
  id               String      @id @default(cuid())
  articleId        String
  userId           String?
  viewed           Boolean     @default(false)
  viewedAt         DateTime?
  markedHelpful    Boolean?
  markedAt         DateTime?
  timeSpentSeconds Int?
  scrollDepth      Float?
  viewedFrom       String?
  searchQuery      String?
  createdAt        DateTime    @default(now())
  help_articles    HelpArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@index([articleId, viewed])
  @@index([userId])
  @@map("help_article_analytics")
}

model HelpArticleCategory {
  id            String        @id @default(cuid())
  name          String
  slug          String        @unique
  description   String?
  icon          String?
  displayOrder  Int           @default(0)
  isActive      Boolean       @default(true)
  help_articles HelpArticle[]

  @@index([displayOrder, isActive])
  @@map("help_article_categories")
}

model HelpArticle {
  id                String                @id @default(cuid())
  categoryId        String?
  title             String
  slug              String                @unique
  content           String
  excerpt           String?
  thumbnailUrl      String?
  videoUrl          String?
  attachments       Json?
  displayOrder      Int                   @default(0)
  tags              String[]              @default([])
  metaDescription   String?
  keywords          String[]              @default([])
  isActive          Boolean               @default(true)
  isFeatured        Boolean               @default(false)
  isPremiumOnly     Boolean               @default(false)
  viewCount         Int                   @default(0)
  helpfulCount      Int                   @default(0)
  notHelpfulCount   Int                   @default(0)
  averageTimeSpent  Float?
  relatedArticleIds String[]              @default([])
  relatedFaqIds     String[]              @default([])
  createdBy         String?
  publishedAt       DateTime?
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  analytics         HelpArticleAnalytic[]
  category          HelpArticleCategory?  @relation(fields: [categoryId], references: [id])

  @@index([categoryId, isActive])
  @@index([isFeatured, isActive])
  @@index([publishedAt])
  @@index([slug])
  @@map("help_articles")
}

model LegalDocumentAcceptance {
  id              String            @id @default(cuid())
  documentId      String
  userId          String
  acceptedAt      DateTime          @default(now())
  ipAddress       String?
  userAgent       String?
  deviceInfo      Json?
  documentVersion String
  documentType    LegalDocumentType
  legal_documents LegalDocument     @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([userId, documentId])
  @@index([documentId])
  @@index([userId, documentType])
  @@map("legal_document_acceptances")
}

model LegalDocument {
  id                 String                    @id @default(cuid())
  documentType       LegalDocumentType
  version            String
  title              String
  content            String
  summary            String?
  effectiveDate      DateTime
  expiryDate         DateTime?
  isActive           Boolean                   @default(false)
  isCurrent          Boolean                   @default(false)
  requiresAcceptance Boolean                   @default(false)
  changesSummary     String?
  previousVersionId  String?
  createdBy          String?
  approvedBy         String?
  approvedAt         DateTime?
  createdAt          DateTime                  @default(now())
  updatedAt          DateTime                  @updatedAt
  acceptances        LegalDocumentAcceptance[]

  @@unique([documentType, version])
  @@index([documentType, isCurrent])
  @@index([effectiveDate])
  @@map("legal_documents")
}

model ListingPriceHistory {
  id                  String             @id @default(cuid())
  listingId           String
  price               Float
  currency            String             @default("MYR")
  reason              String?
  changedAt           DateTime           @default(now())
  marketplaceListings MarketplaceListing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@index([listingId, changedAt])
  @@map("listing_price_history")
}

model LoginAttempt {
  id            String   @id @default(cuid())
  userId        String?
  identifier    String
  ipAddress     String
  userAgent     String?
  success       Boolean
  failureReason String?
  attemptedAt   DateTime @default(now())
  users         User?    @relation(fields: [userId], references: [id])

  @@index([identifier, attemptedAt])
  @@index([ipAddress, attemptedAt])
  @@index([userId, attemptedAt])
  @@map("login_attempts")
}

model MaintenanceSchedule {
  id                String            @id @default(cuid())
  title             String
  description       String
  startTime         DateTime
  endTime           DateTime
  estimatedDuration Int?
  status            MaintenanceStatus @default(SCHEDULED)
  affectedFeatures  String[]          @default([])
  isFullDowntime    Boolean           @default(false)
  severity          String            @default("medium")
  userMessage       String?
  technicalDetails  String?
  updates           Json?
  notifyUsers       Boolean           @default(true)
  notificationSent  Boolean           @default(false)
  notifiedAt        DateTime?
  actualStartTime   DateTime?
  actualEndTime     DateTime?
  completionNotes   String?
  createdBy         String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  @@index([startTime, endTime])
  @@index([status, startTime])
  @@map("maintenance_schedules")
}

model MarketplaceCartItem {
  id                  String             @id @default(cuid())
  userId              String
  listingId           String
  quantity            Int
  addedAt             DateTime           @default(now())
  marketplaceListings MarketplaceListing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  user                User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, listingId])
  @@index([userId])
  @@map("marketplace_cart_items")
}

model MarketplaceDispute {
  id                 String           @id @default(cuid())
  orderId            String
  initiatedBy        String
  reason             String
  status             DisputeStatus    @default(OPEN)
  resolution         Json?
  createdAt          DateTime         @default(now())
  resolvedAt         DateTime?
  user               User             @relation(fields: [initiatedBy], references: [id], onDelete: Cascade)
  marketplace_orders MarketplaceOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([status])
  @@map("marketplace_disputes")
}

model MarketplaceListing {
  id     String      @id @default(cuid())
  userId String
  type   ListingType // PRODUCT or SERVICE

  // Basic Information
  title       String
  description String?
  category    String?
  tags        String[] @default([])
  images      String[] @default([])

  // Location Data
  location        String? // City/area name
  address         String? // Full address
  latitude        Float? // For proximity search
  longitude       Float? // For proximity search
  serviceLocation ServiceLocationType? // Where service is provided

  // Product-specific fields (nullable for services)
  quantity          Int? // Stock quantity
  condition         ProductCondition? // NEW, LIKE_NEW, GOOD, FAIR, POOR
  shippingAvailable Boolean           @default(false)
  shippingFee       Float?

  // Service-specific fields (nullable for products)
  serviceType  ServiceType? // TUTORING, CONSULTATION, etc.
  duration     Int? // Duration in minutes
  durationUnit DurationUnit? // MINUTES, HOURS, DAYS
  maxGuests    Int? // Max participants/guests
  requirements Json? // Prerequisites, materials needed

  // Pricing & Negotiation
  isNegotiable     Boolean @default(false)
  isPriceOnRequest Boolean @default(false)

  // Contact Preferences
  allowDirectContact     Boolean @default(false)
  preferredContactMethod String? // 'in_app', 'phone', 'whatsapp', 'telegram'

  // Status & Visibility
  status     ListingStatus @default(DRAFT)
  isActive   Boolean       @default(true)
  isFeatured Boolean       @default(false)
  viewCount  Int           @default(0)

  // Future: Promotions/Discounts
  hasActivePromotion Boolean   @default(false)
  promotionId        String?
  discountPercentage Float?
  discountAmount     Float?
  discountValidUntil DateTime?

  // Timestamps
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  publishedAt  DateTime?
  expiresAt    DateTime?
  lastBumpedAt DateTime?

  // Relations
  user                 User                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  pricingOptions       MarketplacePricingOption[]
  orders               MarketplaceOrder[]
  priceHistory         ListingPriceHistory[]
  marketplaceCartItems MarketplaceCartItem[]

  @@index([userId, status])
  @@index([type, status, isActive])
  @@index([category, status])
  @@index([location])
  @@index([latitude, longitude])
  @@index([createdAt])
  @@index([publishedAt])
  @@index([isFeatured, isActive, publishedAt])
  @@index([hasActivePromotion, isActive])
  @@map("marketplace_listings")
}

model MarketplacePricingOption {
  id        String @id @default(cuid())
  listingId String

  // Pricing Type
  pricingType PaymentMethodType // MONEY, FREE, TREATS, BARTER

  // Money Pricing
  price          Float?
  currency       String?             @default("MYR")
  priceStructure PriceStructureType? // FIXED, PER_HOUR, PER_DAY, PER_SESSION, PACKAGE

  // Treats/Barter Pricing
  exchangeDescription String?
  exchangeCategory    ExchangeCategory?
  estimatedValue      Float?

  // Package Details
  packageDetails Json?

  // Display & Ordering
  isDefault    Boolean @default(false)
  displayOrder Int     @default(0)
  label        String?

  // Future: Discount/Voucher Support
  allowsVouchers Boolean @default(true)
  minOrderAmount Float?
  maxOrderAmount Float?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  listing MarketplaceListing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  orders  MarketplaceOrder[]

  @@index([listingId])
  @@index([pricingType])
  @@index([isDefault])
  @@map("marketplace_pricing_options")
}

model MarketplaceOrder {
  id              String @id @default(cuid())
  listingId       String
  pricingOptionId String
  buyerId         String
  sellerId        String

  // Order Type
  orderType ListingType // PRODUCT or SERVICE

  // Quantity/Sessions
  quantity Int @default(1)

  // Service Booking Details
  scheduledDate   DateTime?
  scheduledTime   String?
  duration        Int?
  serviceLocation String?
  specialRequests String?

  // Pricing Snapshot
  pricingType    PaymentMethodType // MONEY, FREE, TREATS, BARTER
  priceStructure PriceStructureType?
  unitPrice      Float?
  subtotal       Float?
  platformFee    Float?
  shippingFee    Float?              @default(0.0)
  totalAmount    Float?
  currency       String?             @default("MYR")

  // Exchange/Barter
  exchangeDescription String?
  exchangeFulfilled   Boolean? @default(false)

  // Discount/Voucher
  discountAmount Float?  @default(0)
  voucherCode    String?
  voucherId      String?
  promotionId    String?

  // Seller Payout
  sellerPayout Float?
  payoutStatus PayoutStatus?
  payoutDate   DateTime?

  // Status
  status            OrderStatus        @default(PENDING)
  paymentStatus     PaymentStatus      @default(PENDING)
  fulfillmentStatus FulfillmentStatus? @default(PENDING)

  // Communication
  buyerNotes          String?
  sellerNotes         String?
  contactInfoRevealed Boolean   @default(false)
  revealedAt          DateTime?

  // Shipping (for products)
  shippingAddress Json?
  trackingNumber  String?

  // Payment
  paymentTransactionId String?

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  paidAt      DateTime?
  confirmedAt DateTime?
  shippedAt   DateTime?
  deliveredAt DateTime?
  completedAt DateTime?
  canceledAt  DateTime?
  refundedAt  DateTime?

  // Relations
  marketplaceDisputes                      MarketplaceDispute[]
  users_marketplace_orders_buyerIdTousers  User                     @relation("marketplace_orders_buyerIdTousers", fields: [buyerId], references: [id], onDelete: Cascade)
  marketplaceListings                      MarketplaceListing       @relation(fields: [listingId], references: [id], onDelete: Cascade)
  pricingOption                            MarketplacePricingOption @relation(fields: [pricingOptionId], references: [id])
  paymentTransactions                      PaymentTransaction?      @relation(fields: [paymentTransactionId], references: [id])
  users_marketplace_orders_sellerIdTousers User                     @relation("marketplace_orders_sellerIdTousers", fields: [sellerId], references: [id], onDelete: Cascade)
  reviews                                  MarketplaceReview[]

  @@index([listingId])
  @@index([pricingOptionId])
  @@index([buyerId, status])
  @@index([sellerId, status])
  @@index([status, createdAt])
  @@index([paymentStatus])
  @@index([fulfillmentStatus])
  @@index([scheduledDate])
  @@index([orderType, status])
  @@index([paymentTransactionId])
  @@map("marketplace_orders")
}

model MarketplaceReview {
  id                                          String           @id @default(cuid())
  orderId                                     String
  reviewerId                                  String
  revieweeId                                  String
  rating                                      Int
  comment                                     String?
  createdAt                                   DateTime         @default(now())
  marketplace_orders                          MarketplaceOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  users_marketplace_reviews_revieweeIdTousers User             @relation("marketplace_reviews_revieweeIdTousers", fields: [revieweeId], references: [id], onDelete: Cascade)
  users_marketplace_reviews_reviewerIdTousers User             @relation("marketplace_reviews_reviewerIdTousers", fields: [reviewerId], references: [id], onDelete: Cascade)

  @@unique([orderId, reviewerId])
  @@index([revieweeId, rating])
  @@map("marketplace_reviews")
}

model Match {
  id                              String      @id @default(cuid())
  type                            MatchType
  status                          MatchStatus @default(PENDING)
  compatibility                   Float
  reason                          String
  interests                       String[]
  availability                    Json?
  location                        String?
  message                         String?
  createdAt                       DateTime    @default(now())
  updatedAt                       DateTime    @updatedAt
  expiresAt                       DateTime
  senderId                        String
  receiverId                      String
  users_matches_receiverIdTousers User        @relation("matches_receiverIdTousers", fields: [receiverId], references: [id], onDelete: Cascade)
  users_matches_senderIdTousers   User        @relation("matches_senderIdTousers", fields: [senderId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId, type])
  @@index([createdAt])
  @@index([expiresAt])
  @@index([receiverId])
  @@index([receiverId, status])
  @@index([senderId])
  @@index([senderId, status])
  @@index([status])
  @@index([type])
  @@map("matches")
}

// User Swipe tracking for discovery
model UserSwipe {
  id           String      @id @default(cuid())
  swiperId     String // User who swiped
  swipedUserId String // User who was swiped on
  action       SwipeAction // SKIP or INTERESTED
  createdAt    DateTime    @default(now())

  // Skip tracking - after 3 SKIPs, don't show this user again
  skipCount Int @default(0) // Incremented each time user skips

  // Connection tracking
  connectionSent Boolean @default(false) // True if user sent connection request after INTERESTED
  connectionId   String? // Reference to UserConnection if request was sent

  // Context for matching algorithm
  shownInContext String? // discover, nearby, community_members, etc.
  distanceKm     Float? // Distance between users at time of swipe

  // Relations
  swiper     User @relation("user_swipes_swiperId", fields: [swiperId], references: [id], onDelete: Cascade)
  swipedUser User @relation("user_swipes_swipedUserId", fields: [swipedUserId], references: [id], onDelete: Cascade)

  @@index([swiperId, swipedUserId]) // Allow multiple swipes (for skip counting)
  @@index([swiperId, action])
  @@index([swipedUserId])
  @@index([skipCount])
  @@index([createdAt])
  @@map("user_swipes")
}

// Discovery session tracking to manage shown users
model DiscoverySession {
  id        String    @id @default(cuid())
  userId    String
  startedAt DateTime  @default(now())
  endedAt   DateTime?

  // Session parameters
  filters   Json? // Applied filters (distance, age, interests, etc.)
  latitude  Float?
  longitude Float?

  // Session stats
  totalShown       Int @default(0)
  totalInterested  Int @default(0)
  totalSkips       Int @default(0)
  totalConnections Int @default(0)

  // Track shown users to avoid duplicates in same session
  shownUserIds String[] @default([])

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, startedAt])
  @@map("discovery_sessions")
}

model Message {
  id                               String   @id @default(cuid())
  content                          String
  isRead                           Boolean  @default(false)
  createdAt                        DateTime @default(now())
  senderId                         String
  receiverId                       String
  users_messages_receiverIdTousers User     @relation("messages_receiverIdTousers", fields: [receiverId], references: [id], onDelete: Cascade)
  users_messages_senderIdTousers   User     @relation("messages_senderIdTousers", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([isRead])
  @@index([receiverId])
  @@index([receiverId, isRead])
  @@index([senderId])
  @@index([senderId, receiverId])
  @@map("messages")
}

model NotificationPreference {
  userId       String   @id
  emailEnabled Boolean  @default(true)
  pushEnabled  Boolean  @default(true)
  smsEnabled   Boolean  @default(false)
  inAppEnabled Boolean  @default(true)
  preferences  Json     @default("{}")
  quietHours   Json?
  timezone     String   @default("Asia/Kuala_Lumpur")
  updatedAt    DateTime @updatedAt
  users        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

model Notification {
  id                String           @id @default(cuid())
  type              NotificationType
  title             String
  message           String
  actionUrl         String?
  metadata          Json?
  createdAt         DateTime         @default(now())
  userId            String
  channels          String[]         @default([])
  deliveredAt       DateTime?
  expiresAt         DateTime?
  priority          String           @default("normal")
  readAt            DateTime?
  relatedEntityId   String?
  relatedEntityType String?
  scheduledFor      DateTime?
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([priority])
  @@index([readAt])
  @@index([type])
  @@index([userId, createdAt])
  @@index([userId])
  @@index([userId, readAt])
  @@map("notifications")
}

// DEPRECATED: Old unified onboarding system - kept for backward compatibility
// Use AppPreviewScreen and UserSetupScreen instead
model OnboardingAnalytic {
  id                 String           @id @default(cuid())
  screenId           String
  userId             String?
  viewed             Boolean          @default(false)
  viewedAt           DateTime?
  completed          Boolean          @default(false)
  completedAt        DateTime?
  skipped            Boolean          @default(false)
  skippedAt          DateTime?
  timeSpentSeconds   Int?
  deviceInfo         Json?
  appVersion         String?
  createdAt          DateTime         @default(now())
  onboarding_screens OnboardingScreen @relation(fields: [screenId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([screenId, viewed])
  @@index([userId])
  @@map("onboarding_analytics")
}

// DEPRECATED: Old unified onboarding system - kept for backward compatibility
// Use AppPreviewScreen and UserSetupScreen instead
model OnboardingScreen {
  id              String               @id @default(cuid())
  screenOrder     Int
  title           String
  subtitle        String?
  description     String?
  imageUrl        String?
  videoUrl        String?
  ctaText         String?
  ctaAction       String?
  ctaUrl          String?
  backgroundColor String?
  isSkippable     Boolean              @default(true)
  isActive        Boolean              @default(true)
  targetAudience  String               @default("all")
  minAppVersion   String?
  metadata        Json?
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  analytics       OnboardingAnalytic[]

  @@index([isActive])
  @@index([screenOrder, isActive])
  @@map("onboarding_screens")
}

// NEW: App Preview Screens (Pre-Authentication)
// Shown before login/registration to introduce the app
model AppPreviewScreen {
  id              String               @id @default(cuid())
  screenOrder     Int
  title           String
  subtitle        String?
  description     String?
  imageUrl        String?
  videoUrl        String?
  animationUrl    String?
  iconName        String?
  // Legacy fields - use primaryButton and secondaryButton instead
  ctaText         String?
  ctaAction       String? // "next", "skip", "get_started"
  // New dual button support
  primaryButton   Json? // { text: "Get Started", action: "get_started", style: "primary", icon?: "arrow-right" }
  secondaryButton Json? // { text: "Skip", action: "skip", style: "secondary", icon?: "forward" }
  backgroundColor String?              @default("#FFFFFF")
  textColor       String?              @default("#000000")
  isSkippable     Boolean              @default(true)
  isActive        Boolean              @default(true)
  minAppVersion   String?
  metadata        Json?
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  analytics       AppPreviewAnalytic[]

  @@unique([title, screenOrder])
  @@index([isActive, screenOrder])
  @@map("app_preview_screens")
}

// Analytics for App Preview Screens (anonymous tracking)
model AppPreviewAnalytic {
  id               String           @id @default(cuid())
  screenId         String
  sessionId        String? // Anonymous session identifier
  userId           String? // If user later registers/logs in
  viewed           Boolean          @default(false)
  viewedAt         DateTime?
  completed        Boolean          @default(false)
  completedAt      DateTime?
  skipped          Boolean          @default(false)
  skippedAt        DateTime?
  timeSpentSeconds Int?
  deviceInfo       Json?
  appVersion       String?
  createdAt        DateTime         @default(now())
  screen           AppPreviewScreen @relation(fields: [screenId], references: [id], onDelete: Cascade)

  @@index([screenId, viewed])
  @@index([sessionId])
  @@index([userId])
  @@index([createdAt])
  @@map("app_preview_analytics")
}

// NEW: User Setup Screens (Post-Authentication)
// Personalized onboarding after registration/verification
model UserSetupScreen {
  id              String              @id @default(cuid())
  screenOrder     Int
  screenType      UserSetupScreenType // "profile", "network", "community", "preferences", "tutorial"
  title           String
  subtitle        String?
  description     String?
  imageUrl        String?
  videoUrl        String?
  iconName        String?
  ctaText         String?
  ctaAction       String? // "complete_profile", "add_connections", "join_communities", etc.
  ctaUrl          String?
  backgroundColor String?             @default("#FFFFFF")
  textColor       String?             @default("#000000")
  isRequired      Boolean             @default(false) // Cannot skip if true
  isSkippable     Boolean             @default(true)
  isActive        Boolean             @default(true)
  targetAudience  String              @default("all") // "all", "new_users", "verified_users"
  requiredFields  String[]            @default([]) // Required profile fields for this screen
  minAppVersion   String?
  metadata        Json?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  analytics       UserSetupAnalytic[]

  @@unique([title, screenOrder])
  @@index([isActive, screenOrder])
  @@index([screenType])
  @@index([isRequired])
  @@map("user_setup_screens")
}

// Analytics for User Setup Screens (authenticated users only)
model UserSetupAnalytic {
  id               String          @id @default(cuid())
  screenId         String
  userId           String // Always required (authenticated users only)
  viewed           Boolean         @default(false)
  viewedAt         DateTime?
  completed        Boolean         @default(false)
  completedAt      DateTime?
  skipped          Boolean         @default(false)
  skippedAt        DateTime?
  timeSpentSeconds Int?
  actionsTaken     Json? // Track specific actions user took on this screen
  deviceInfo       Json?
  appVersion       String?
  createdAt        DateTime        @default(now())
  screen           UserSetupScreen @relation(fields: [screenId], references: [id], onDelete: Cascade)
  user             User            @relation("UserSetupAnalytics", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([screenId, userId])
  @@index([userId, completed])
  @@index([screenId, viewed])
  @@index([createdAt])
  @@map("user_setup_analytics")
}

enum UserSetupScreenType {
  PROFILE // Complete profile information
  NETWORK // Set up trust network, add connections
  COMMUNITY // Join communities, follow interests
  PREFERENCES // Notification, privacy, app preferences
  TUTORIAL // Feature tours and walkthroughs
  VERIFICATION // Additional verification steps

  @@map("user_setup_screen_type")
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  userId    String
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  ipAddress String
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@map("password_reset_tokens")
}

model PaymentProviderRouting {
  id         String          @id @default(cuid())
  ruleName   String
  providerId String
  conditions Json
  priority   Int             @default(0)
  isActive   Boolean         @default(true)
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  provider   PaymentProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@index([priority, isActive])
  @@index([providerId, isActive])
  @@map("payment_provider_routing")
}

model PaymentProvider {
  id                  String                   @id @default(cuid())
  providerCode        String                   @unique
  providerName        String
  providerType        String
  supportedCountries  String[]
  supportedCurrencies String[]
  isActive            Boolean                  @default(true)
  isDefault           Boolean                  @default(false)
  priorityOrder       Int                      @default(0)
  configuration       Json                     @default("{}")
  feeStructure        Json                     @default("{}")
  capabilities        Json                     @default("{}")
  webhookConfig       Json?
  createdAt           DateTime                 @default(now())
  updatedAt           DateTime                 @updatedAt
  routing             PaymentProviderRouting[]
  paymentTransactions PaymentTransaction[]

  @@index([isActive, priorityOrder])
  @@index([providerCode])
  @@map("payment_providers")
}

model PaymentTransaction {
  id                     String                @id @default(cuid())
  userId                 String
  transactionType        TransactionType
  referenceType          String
  referenceId            String
  amount                 Float
  currency               String                @default("MYR")
  totalFees              Float                 @default(0.0)
  platformFee            Float                 @default(0.0)
  gatewayFee             Float                 @default(0.0)
  netAmount              Float                 @default(0.0)
  providerId             String
  gatewayTransactionId   String                @unique
  gatewayPaymentMethodId String?
  gatewayMetadata        Json?
  status                 PaymentStatus         @default(PENDING)
  failureReason          String?
  processedAt            DateTime?
  refundedAmount         Float?                @default(0.0)
  refundedAt             DateTime?
  refundReason           String?
  description            String?
  metadata               Json?
  createdAt              DateTime              @default(now())
  updatedAt              DateTime              @updatedAt
  // Payment retry and tracking fields
  paymentMethod          String? // 'xendit', 'stripe', 'ewallet', 'bank_transfer', etc.
  transactionId          String? // External transaction ID from payment gateway
  xenditInvoiceId        String? // Xendit specific invoice ID
  xenditInvoiceUrl       String? // Xendit invoice URL for retry payment
  paidAt                 DateTime? // When payment was completed
  eventTickets           EventTicket[]
  marketplace_orders     MarketplaceOrder[]
  provider               PaymentProvider       @relation(fields: [providerId], references: [id])
  user                   User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  payoutDistributions    PayoutDistribution[]
  subscriptionPayments   SubscriptionPayment[]
  fees                   TransactionFee[]

  @@index([createdAt])
  @@index([gatewayTransactionId])
  @@index([processedAt, status])
  @@index([providerId, status])
  @@index([referenceType, referenceId])
  @@index([transactionType])
  @@index([transactionType, status])
  @@index([userId, status])
  @@index([xenditInvoiceId])
  @@index([status, paidAt])
  @@map("payment_transactions")
}

model PayoutDistribution {
  id                   String             @id @default(cuid())
  paymentTransactionId String
  recipientId          String
  recipientType        String // 'event_organizer', 'marketplace_seller', 'service_provider', 'platform'
  amount               Float
  currency             String             @default("MYR")
  status               PayoutStatus       @default(HELD)
  releaseDate          DateTime? // When funds can be released (escrow hold until this date)
  gatewayPayoutId      String?
  holdReason           String? // 'awaiting_delivery', 'awaiting_event', 'dispute', 'verification', etc.
  canReleaseAt         DateTime? // Earliest possible release time (calculated based on rules)
  autoReleaseEnabled   Boolean            @default(true) // Auto-release when releaseDate passes
  requiresManualReview Boolean            @default(false) // Admin must approve release
  metadata             Json? // Additional context (eventId, orderId, etc.)
  notes                String? // Admin notes or release conditions
  createdAt            DateTime           @default(now())
  releasedAt           DateTime?
  canceledAt           DateTime?
  failureReason        String? // If payout fails
  paymentTransactions  PaymentTransaction @relation(fields: [paymentTransactionId], references: [id], onDelete: Cascade)
  user                 User               @relation(fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([paymentTransactionId])
  @@index([recipientId, status])
  @@index([releaseDate, status])
  @@index([canReleaseAt, status, autoReleaseEnabled])
  @@index([status, requiresManualReview])
  @@map("payout_distributions")
}

model PlatformFeeConfig {
  id              String           @id @default(cuid())
  configName      String
  transactionType TransactionType
  feePercentage   Float?
  feeFixed        Float?
  minFee          Float?
  maxFee          Float?
  currency        String           @default("MYR")
  conditions      Json             @default("{}")
  recipientType   String           @default("platform")
  recipientId     String?
  isActive        Boolean          @default(true)
  priority        Int              @default(0)
  effectiveFrom   DateTime         @default(now())
  effectiveUntil  DateTime?
  description     String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  fees            TransactionFee[]

  @@index([effectiveFrom, effectiveUntil])
  @@index([priority, isActive])
  @@index([transactionType, isActive])
  @@map("platform_fee_configs")
}

model PointHistory {
  id          String    @id @default(cuid())
  points      Int
  action      String
  description String?
  createdAt   DateTime  @default(now())
  userId      String
  expiresAt   DateTime? // When points expire
  expired     Boolean   @default(false) // Whether points have expired
  expiredAt   DateTime? // When points actually expired
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([action])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@index([userId])
  @@index([expiresAt, expired])
  @@map("point_histories")
}

model ProfileCompletionStatus {
  userId              String    @id
  completionScore     Float     @default(0.0)
  completionLevel     String    @default("starter")
  hasProfilePicture   Boolean   @default(false)
  hasDisplayName      Boolean   @default(false)
  hasBio              Boolean   @default(false)
  hasLocation         Boolean   @default(false)
  hasInterests        Boolean   @default(false)
  hasLanguages        Boolean   @default(false)
  hasProfession       Boolean   @default(false)
  hasDateOfBirth      Boolean   @default(false)
  hasSocialHandles    Boolean   @default(false)
  hasVerifiedEmail    Boolean   @default(false)
  hasVerifiedPhone    Boolean   @default(false)
  fieldWeights        Json      @default("{}")
  missingFields       String[]  @default([])
  nextRecommendation  String?
  reachedBasic        Boolean   @default(false)
  reachedIntermediate Boolean   @default(false)
  reachedComplete     Boolean   @default(false)
  reachedExpert       Boolean   @default(false)
  pointsEarned        Int       @default(0)
  badgesUnlocked      String[]  @default([])
  lastCalculatedAt    DateTime  @default(now())
  firstCompleteAt     DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([completionLevel])
  @@index([completionScore])
  @@index([lastCalculatedAt])
  @@map("profile_completion_status")
}

model PushSubscription {
  id        String   @id @default(cuid())
  userId    String   @unique
  endpoint  String
  p256dh    String
  auth      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("push_subscriptions")
}

model Redemption {
  id          String           @id @default(cuid())
  status      RedemptionStatus @default(PENDING)
  notes       String?
  redeemedAt  DateTime         @default(now())
  processedAt DateTime?
  userId      String
  rewardId    String
  rewards     Reward           @relation(fields: [rewardId], references: [id], onDelete: Cascade)
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([rewardId])
  @@index([status])
  @@index([userId])
  @@map("redemptions")
}

model ReferralCampaign {
  id                   String     @id @default(cuid())
  campaignCode         String     @unique
  campaignName         String
  description          String?
  referrerRewardType   String     @default("points")
  referrerRewardAmount Float      @default(100.0)
  refereeRewardType    String     @default("points")
  refereeRewardAmount  Float      @default(50.0)
  bonusRewards         Json?
  activationCriteria   Json       @default("{}")
  startDate            DateTime
  endDate              DateTime?
  maxReferrals         Int?
  maxPerUser           Int?
  targetCountries      String[]   @default([])
  targetUserSegment    String?
  isActive             Boolean    @default(true)
  isPaused             Boolean    @default(false)
  totalReferrals       Int        @default(0)
  totalSignups         Int        @default(0)
  totalActivated       Int        @default(0)
  totalRewardsGiven    Float      @default(0.0)
  createdAt            DateTime   @default(now())
  updatedAt            DateTime   @updatedAt
  referrals            Referral[]

  @@index([campaignCode, isActive])
  @@index([isActive, isPaused])
  @@index([startDate, endDate])
  @@map("referral_campaigns")
}

model ReferralReward {
  id                String               @id @default(cuid())
  referralId        String
  userId            String
  rewardType        String
  rewardAmount      Float?
  rewardDuration    Int?
  description       String
  status            ReferralRewardStatus @default(PENDING)
  isMilestoneReward Boolean              @default(false)
  milestoneCount    Int?
  awardedAt         DateTime?
  expiresAt         DateTime?
  claimedAt         DateTime?
  metadata          Json?
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  referrals         Referral             @relation(fields: [referralId], references: [id], onDelete: Cascade)
  user              User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([awardedAt])
  @@index([isMilestoneReward])
  @@index([referralId])
  @@index([status])
  @@index([userId, status])
  @@map("referral_rewards")
}

model ReferralStat {
  userId                String    @id
  totalReferrals        Int       @default(0)
  totalClicks           Int       @default(0)
  totalSignups          Int       @default(0)
  totalActivated        Int       @default(0)
  clickToSignupRate     Float     @default(0.0)
  signupToActiveRate    Float     @default(0.0)
  overallConversionRate Float     @default(0.0)
  totalPointsEarned     Int       @default(0)
  totalCreditsEarned    Float     @default(0.0)
  totalRewardsCount     Int       @default(0)
  milestonesReached     Json      @default("[]")
  bestConversionMonth   String?
  bestConversionCount   Int       @default(0)
  currentStreak         Int       @default(0)
  longestStreak         Int       @default(0)
  leaderboardRank       Int?
  topReferrerBadge      Boolean   @default(false)
  lastReferralAt        DateTime?
  lastActivationAt      DateTime?
  lastCalculatedAt      DateTime  @default(now())
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  users                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([leaderboardRank])
  @@index([topReferrerBadge])
  @@index([totalActivated])
  @@index([totalPointsEarned])
  @@map("referral_stats")
}

model Referral {
  id                                String            @id @default(cuid())
  referrerId                        String
  refereeId                         String?
  referralCode                      String            @unique
  referralMethod                    String?
  referralSource                    String?
  campaignId                        String?
  clickedAt                         DateTime?
  signedUpAt                        DateTime?
  activatedAt                       DateTime?
  expiredAt                         DateTime?
  isActivated                       Boolean           @default(false)
  activationCriteria                Json?
  referrerRewardGiven               Boolean           @default(false)
  refereeRewardGiven                Boolean           @default(false)
  ipAddress                         String?
  userAgent                         String?
  deviceInfo                        Json?
  metadata                          Json?
  notes                             String?
  createdAt                         DateTime          @default(now())
  updatedAt                         DateTime          @updatedAt
  referralRewards                   ReferralReward[]
  campaign                          ReferralCampaign? @relation(fields: [campaignId], references: [id])
  users_referrals_refereeIdTousers  User?             @relation("referrals_refereeIdTousers", fields: [refereeId], references: [id])
  users_referrals_referrerIdTousers User              @relation("referrals_referrerIdTousers", fields: [referrerId], references: [id], onDelete: Cascade)

  @@index([activatedAt])
  @@index([campaignId])
  @@index([createdAt])
  @@index([isActivated])
  @@index([refereeId])
  @@index([referralCode])
  @@index([referrerId, isActivated])
  @@index([signedUpAt])
  @@map("referrals")
}

model RefreshToken {
  id          String   @id @default(cuid())
  tokenHash   String   @unique
  tokenFamily String
  userId      String
  isRevoked   Boolean  @default(false)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([expiresAt])
  @@index([tokenHash])
  @@index([userId])
  @@map("refresh_tokens")
}

model Reward {
  id             String       @id @default(cuid())
  title          String
  description    String
  pointsRequired Int
  category       String
  partner        String
  quantity       Int          @default(0)
  imageUrl       String?
  isActive       Boolean      @default(true)
  
  // Redemption fulfillment data (configured by admin)
  voucherCode     String?      // Promo/discount code to show user
  voucherImageUrl String?      // QR code or voucher image URL
  redemptionLink  String?      // External link for redemption
  instructions    String?      // Instructions on how to use the reward
  validityDays    Int?         // How many days the reward is valid after redemption
  fulfillmentData Json?        // Flexible JSON field for any additional data
  
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  redemptions    Redemption[]

  @@unique([title, category])
  @@index([category])
  @@index([isActive])
  @@map("rewards")
}

model SecurityEvent {
  id          String   @id @default(cuid())
  userId      String
  eventType   String
  severity    String   @default("medium")
  description String
  metadata    Json?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([eventType])
  @@index([severity])
  @@index([userId, createdAt])
  @@map("security_events")
}

model SubscriptionPayment {
  id                   String              @id @default(cuid())
  subscriptionId       String
  userId               String
  amount               Float
  currency             String              @default("MYR")
  billingPeriodStart   DateTime
  billingPeriodEnd     DateTime
  status               PaymentStatus       @default(PENDING)
  attemptCount         Int                 @default(1)
  paymentTransactionId String?
  gatewayInvoiceId     String?
  dueDate              DateTime
  paidAt               DateTime?
  failedAt             DateTime?
  failureReason        String?
  createdAt            DateTime            @default(now())
  paymentTransactions  PaymentTransaction? @relation(fields: [paymentTransactionId], references: [id])
  subscriptions        UserSubscription    @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  user                 User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([dueDate])
  @@index([paymentTransactionId])
  @@index([status])
  @@index([subscriptionId, status])
  @@index([userId, status])
  @@map("subscription_payments")
}

model SubscriptionTier {
  id            String             @id @default(cuid())
  tierCode      String             @unique
  tierName      String
  description   String?
  price         Float              @default(0.0)
  currency      String             @default("MYR")
  billingCycle  String             @default("MONTHLY")
  features      Json               @default("{}")
  displayOrder  Int                @default(0)
  isActive      Boolean            @default(true)
  isPublic      Boolean            @default(true)
  trialDays     Int?               @default(0)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  subscriptions UserSubscription[]

  @@index([displayOrder])
  @@index([isActive, isPublic])
  @@index([tierCode, isActive])
  @@map("subscription_tiers")
}

model TransactionFee {
  id                  String             @id @default(cuid())
  transactionId       String
  feeConfigId         String?
  feeType             String
  feePercentage       Float?
  feeFixed            Float?
  calculatedFee       Float
  recipientType       String
  recipientId         String?
  currency            String             @default("MYR")
  description         String?
  appliedAt           DateTime           @default(now())
  feeConfig           PlatformFeeConfig? @relation(fields: [feeConfigId], references: [id])
  paymentTransactions PaymentTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  @@index([feeConfigId])
  @@index([recipientType, recipientId])
  @@index([transactionId, feeType])
  @@map("transaction_fees")
}

model TravelBucketList {
  id                String    @id @default(cuid())
  userId            String
  country           String
  city              String?
  destination       String
  description       String?
  priority          String    @default("medium")
  targetYear        Int?
  estimatedBudget   Float?
  status            String    @default("planning")
  visitedDate       DateTime?
  isPublic          Boolean   @default(true)
  seekingCompanions Boolean   @default(false)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([country])
  @@index([seekingCompanions])
  @@index([userId, status])
  @@map("travel_bucket_list")
}

model TravelCompanion {
  id                                         String     @id @default(cuid())
  tripId                                     String
  userId                                     String
  companionId                                String?
  companionName                              String?
  companionEmail                             String?
  companionPhone                             String?
  invitationStatus                           String     @default("pending")
  canRequestIntro                            Boolean    @default(true)
  relationship                               String?
  notes                                      String?
  hasVouched                                 Boolean    @default(false)
  vouchId                                    String?
  addedAt                                    DateTime   @default(now())
  verifiedAt                                 DateTime?
  users_travel_companions_companionIdTousers User?      @relation("travel_companions_companionIdTousers", fields: [companionId], references: [id])
  travelTrips                                TravelTrip @relation(fields: [tripId], references: [id], onDelete: Cascade)
  users_travel_companions_userIdTousers      User       @relation("travel_companions_userIdTousers", fields: [userId], references: [id], onDelete: Cascade)

  @@index([companionId])
  @@index([invitationStatus])
  @@index([tripId])
  @@index([userId])
  @@map("travel_companions")
}

model TravelHighlight {
  id            String     @id @default(cuid())
  tripId        String
  title         String
  description   String?
  highlightType String
  image         String?
  date          DateTime?
  location      String?
  createdAt     DateTime   @default(now())
  travelTrips   TravelTrip @relation(fields: [tripId], references: [id], onDelete: Cascade)

  @@index([highlightType])
  @@index([tripId])
  @@map("travel_highlights")
}

model TravelLocation {
  id             String     @id @default(cuid())
  tripId         String
  country        String
  city           String
  placeName      String?
  placeType      String?
  visitDate      DateTime?
  duration       Int?
  rating         Int?
  notes          String?
  wouldRecommend Boolean    @default(true)
  tips           String?
  images         String[]   @default([])
  latitude       Float?
  longitude      Float?
  createdAt      DateTime   @default(now())
  travelTrips    TravelTrip @relation(fields: [tripId], references: [id], onDelete: Cascade)

  @@index([country, city])
  @@index([placeType])
  @@index([tripId])
  @@map("travel_locations")
}

model TravelStat {
  userId                String    @id
  totalTrips            Int       @default(0)
  countriesVisited      Int       @default(0)
  citiesVisited         Int       @default(0)
  continentsVisited     Int       @default(0)
  totalTravelDays       Int       @default(0)
  countriesList         String[]  @default([])
  continentsList        String[]  @default([])
  travelCompanionsCount Int       @default(0)
  soloTripsCount        Int       @default(0)
  firstTripDate         DateTime?
  lastTripDate          DateTime?
  favoriteDestination   String?
  travelFrequency       String?
  averageTripDuration   Int?
  lastCalculatedAt      DateTime  @default(now())
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  users                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([countriesVisited])
  @@index([totalTrips])
  @@map("travel_stats")
}

model TravelTrip {
  id                String            @id @default(cuid())
  userId            String
  title             String
  description       String?
  purpose           String?
  countries         String[]          @default([])
  cities            String[]          @default([])
  startDate         DateTime
  endDate           DateTime?
  duration          Int?
  coverImage        String?
  images            String[]          @default([])
  isPublic          Boolean           @default(true)
  isFeatured        Boolean           @default(false)
  tags              String[]          @default([])
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  travelCompanions  TravelCompanion[]
  travel_highlights TravelHighlight[]
  travel_locations  TravelLocation[]
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([countries])
  @@index([startDate])
  @@index([userId, isPublic])
  @@index([userId, startDate])
  @@map("travel_trips")
}

model UserActivity {
  id           String   @id @default(cuid())
  userId       String
  activityType String
  entityType   String
  entityId     String
  visibility   String   @default("public")
  createdAt    DateTime @default(now())
  users        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([activityType])
  @@index([userId, createdAt])
  @@map("user_activities")
}

model UserBadge {
  id       String   @id @default(cuid())
  earnedAt DateTime @default(now())
  userId   String
  badgeId  String
  badges   Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  users    User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  @@index([userId])
  @@map("user_badges")
}

model UserBlock {
  id                                 String   @id @default(cuid())
  blockerId                          String
  blockedId                          String
  reason                             String?
  blockedAt                          DateTime @default(now())
  users_user_blocks_blockedIdTousers User     @relation("user_blocks_blockedIdTousers", fields: [blockedId], references: [id], onDelete: Cascade)
  users_user_blocks_blockerIdTousers User     @relation("user_blocks_blockerIdTousers", fields: [blockerId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockedId])
  @@index([blockerId])
  @@map("user_blocks")
}

model UserConnection {
  id                                        String             @id @default(cuid())
  initiatorId                               String
  receiverId                                String
  status                                    ConnectionStatus   @default(PENDING)
  message                                   String?
  relationshipType                          String?
  relationshipCategory                      String?
  howWeMet                                  String?
  trustStrength                             Float              @default(0.0)
  interactionCount                          Int                @default(0)
  lastInteraction                           DateTime?
  badges                                    String[]           @default([])
  tags                                      String[]           @default([])
  mutualFriendsCount                        Int                @default(0)
  mutualCommunitiesCount                    Int                @default(0)
  createdAt                                 DateTime           @default(now())
  respondedAt                               DateTime?
  connectedAt                               DateTime?
  removedAt                                 DateTime?
  removedBy                                 String?
  canReconnectAt                            DateTime?
  connection_reviews                        ConnectionReview[]
  trust_moments                             TrustMoment[]
  users_user_connections_initiatorIdTousers User               @relation("user_connections_initiatorIdTousers", fields: [initiatorId], references: [id], onDelete: Cascade)
  users_user_connections_receiverIdTousers  User               @relation("user_connections_receiverIdTousers", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([initiatorId, receiverId])
  @@index([badges])
  @@index([canReconnectAt])
  @@index([initiatorId])
  @@index([initiatorId, status])
  @@index([receiverId])
  @@index([receiverId, status])
  @@index([relationshipCategory])
  @@index([status])
  @@index([trustStrength])
  @@map("user_connections")
}

model UserLocation {
  userId             String    @id
  currentCity        String?
  countryOfResidence String?
  currentLocation    String?
  nationality        String?
  originallyFrom     String?
  timezone           String    @default("Asia/Kuala_Lumpur")
  preferredLanguage  String    @default("en")
  currency           String    @default("MYR")
  updatedAt          DateTime  @updatedAt
  lastLocationUpdate DateTime?
  latitude           Float?
  longitude          Float?
  user               User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([countryOfResidence])
  @@index([currentCity])
  @@index([latitude, longitude])
  @@index([timezone])
  @@map("user_locations")
}

model UserMetadata {
  userId         String   @id
  referralCode   String   @unique
  membershipId   String?  @unique
  referralSource String?
  utmSource      String?
  utmMedium      String?
  utmCampaign    String?
  affiliateId    String?
  lifetimeValue  Float    @default(0.0)
  ipAddress      String?
  userAgent      String?
  tags           String[] @default([])
  notes          String?
  internalNotes  String?
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([affiliateId])
  @@index([referralSource])
  @@map("user_metadata")
}

model UserPaymentMethod {
  id              String    @id @default(cuid())
  userId          String
  provider        String
  gatewayMethodId String
  type            String
  lastFour        String?
  brand           String?
  expiresAt       DateTime?
  isDefault       Boolean   @default(false)
  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  users           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, isDefault])
  @@map("user_payment_methods")
}

model UserPreference {
  userId                     String   @id
  darkMode                   Boolean  @default(false)
  googleCalendarConnected    Boolean  @default(false)
  googleCalendarRefreshToken String?
  pushToken                  String?
  preferences                Json     @default("{}")
  updatedAt                  DateTime @updatedAt
  users                      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preferences")
}

model UserPrivacy {
  userId                  String    @id
  profileVisibility       String    @default("public")
  searchableByPhone       Boolean   @default(true)
  searchableByEmail       Boolean   @default(true)
  showLocation            Boolean   @default(true)
  locationPrecision       String    @default("city")
  searchableByUsername    Boolean   @default(true)
  allowDirectMessages     Boolean   @default(true)
  allowMessagesViaPhone   Boolean   @default(true)
  consentToDataProcessing Boolean   @default(true)
  consentToMarketing      Boolean   @default(false)
  consentDate             DateTime?
  deletionRequestedAt     DateTime?
  deletionScheduledFor    DateTime?
  dataExportRequestedAt   DateTime?
  updatedAt               DateTime  @updatedAt
  users                   User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([deletionRequestedAt])
  @@index([profileVisibility])
  @@map("user_privacy")
}

model UserProfile {
  userId          String    @id
  displayName     String?
  profilePicture  String?
  bio             String?
  shortBio        String?
  dateOfBirth     DateTime?
  gender          String?
  age             Int?
  profession      String?
  occupation      String?
  website         String?
  personalityType String?
  interests       String[]  @default([])
  languages       String[]  @default([])
  instagramHandle String?
  linkedinHandle  String?
  travelStyle     String?
  bucketList      String[]  @default([])
  travelBio       String?
  customFields    Json?
  locationPrivacy String    @default("friends") // "public", "friends", "private"
  updatedAt       DateTime  @updatedAt
  users           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([displayName])
  @@map("user_profiles")
}

model UserSecurity {
  userId               String    @id
  emailVerifiedAt      DateTime?
  phoneVerifiedAt      DateTime?
  lastSeenAt           DateTime?
  lastLoginAt          DateTime?
  lastLoginLocation    String?
  lastPasswordChangeAt DateTime?
  passwordVersion      Int       @default(1) // Incremented on password change to invalidate old tokens
  mfaEnabled           Boolean   @default(false)
  mfaSecret            String?
  mfaRecoveryEmail     String?
  lastMfaAuthAt        DateTime?
  mfaBackupCodes       String[]  @default([])
  accountLockedReason  String?
  lockoutUntil         DateTime?
  suspendedUntil       DateTime?
  suspensionReason     String?
  updatedAt            DateTime  @updatedAt
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([emailVerifiedAt])
  @@index([lastLoginAt])
  @@index([mfaEnabled])
  @@index([phoneVerifiedAt])
  @@map("user_security")
}

model UserSession {
  id             String   @id @default(cuid())
  userId         String
  sessionToken   String   @unique
  deviceInfo     Json?
  ipAddress      String
  userAgent      String?
  locationData   Json?
  isActive       Boolean  @default(true)
  lastActivityAt DateTime @default(now())
  expiresAt      DateTime
  createdAt      DateTime @default(now())
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([expiresAt])
  @@index([sessionToken])
  @@index([userId, isActive])
  @@map("user_sessions")
}

model UserStat {
  userId            String   @id
  eventsAttended    Int      @default(0)
  eventsHosted      Int      @default(0)
  vouchesGiven      Int      @default(0)
  vouchesReceived   Int      @default(0)
  listingsPosted    Int      @default(0)
  servicesProvided  Int      @default(0)
  communitiesJoined Int      @default(0)
  totalPoints       Int      @default(0)
  lastCalculatedAt  DateTime @default(now())
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([eventsAttended])
  @@index([totalPoints])
  @@map("user_stats")
}

model UserSubscription {
  id                    String                @id @default(cuid())
  userId                String
  tierId                String
  status                SubscriptionStatus    @default(ACTIVE)
  currentPeriodStart    DateTime
  currentPeriodEnd      DateTime
  cancelAt              DateTime?
  canceledAt            DateTime?
  trialStart            DateTime?
  trialEnd              DateTime?
  paymentProviderId     String?
  gatewaySubscriptionId String?
  usageData             Json                  @default("{}")
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  subscriptionPayments  SubscriptionPayment[]
  tiers                 SubscriptionTier      @relation(fields: [tierId], references: [id])
  users                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([currentPeriodEnd])
  @@index([gatewaySubscriptionId])
  @@index([status])
  @@index([tierId, status])
  @@index([userId, status])
  @@map("user_subscriptions")
}

model User {
  id                          String                   @id @default(cuid())
  email                       String?                  @unique
  phone                       String?                  @unique
  dialCode                    String? // e.g., "+60", "+65", "+1"
  password                    String?
  fullName                    String
  role                        UserRole                 @default(GENERAL_USER)
  totalPoints                 Int                      @default(0)
  pointsExpired               Int                      @default(0) // Lifetime expired points
  pointsSpent                 Int                      @default(0) // Lifetime spent/redeemed points
  createdAt                   DateTime                 @default(now())
  updatedAt                   DateTime                 @updatedAt
  referredById                String?
  username                    String?                  @unique
  deletedAt                   DateTime?
  status                      UserStatus               @default(ACTIVE)
  trustLevel                  String                   @default("starter")
  trustScore                  Float                    @default(0.0)
  authIdentities              AuthIdentity[]
  cardGameFeedbacks           CardGameFeedback[]
  cardGameReplies             CardGameReply[]
  cardGameReplyUpvotes        CardGameReplyUpvote[]
  cardGameUpvotes             CardGameUpvote[]
  cardGameSessions            CardGameSession[]
  communities                 Community[]
  communityMembers            CommunityMember[]
  connectionReviewsReceived   ConnectionReview[]       @relation("connection_reviews_revieweeIdTousers")
  connectionReviewsGiven      ConnectionReview[]       @relation("connection_reviews_reviewerIdTousers")
  connectionStats             ConnectionStat?
  deviceRegistrations         DeviceRegistration[]
  emailVerificationTokens     EmailVerificationToken[]
  emailChangeRequests         EmailChangeRequest[]
  eventParticipants           EventParticipant[]
  eventTickets                EventTicket[]
  events                      Event[]
  featureUsage                FeatureUsage[]
  loginAttempts               LoginAttempt[]
  marketplaceCartItems        MarketplaceCartItem[]
  marketplaceDisputes         MarketplaceDispute[]
  marketplaceListings         MarketplaceListing[]
  ordersAsBuyer               MarketplaceOrder[]       @relation("marketplace_orders_buyerIdTousers")
  ordersAsSeller              MarketplaceOrder[]       @relation("marketplace_orders_sellerIdTousers")
  marketplaceReviewsReceived  MarketplaceReview[]      @relation("marketplace_reviews_revieweeIdTousers")
  marketplaceReviewsGiven     MarketplaceReview[]      @relation("marketplace_reviews_reviewerIdTousers")
  matchesReceived             Match[]                  @relation("matches_receiverIdTousers")
  matchesSent                 Match[]                  @relation("matches_senderIdTousers")
  swipesMade                  UserSwipe[]              @relation("user_swipes_swiperId")
  swipesReceived              UserSwipe[]              @relation("user_swipes_swipedUserId")
  discoverySessions           DiscoverySession[]
  messagesReceived            Message[]                @relation("messages_receiverIdTousers")
  messagesSent                Message[]                @relation("messages_senderIdTousers")
  notificationPreferences     NotificationPreference?
  notifications               Notification[]
  passwordResetTokens         PasswordResetToken[]
  paymentTransactions         PaymentTransaction[]
  payoutDistributions         PayoutDistribution[]
  pointHistories              PointHistory[]
  profileCompletionStatus     ProfileCompletionStatus?
  pushSubscription            PushSubscription?
  redemptions                 Redemption[]
  referralRewards             ReferralReward[]
  referralStats               ReferralStat?
  referralsAsReferee          Referral[]               @relation("referrals_refereeIdTousers")
  referralsAsReferrer         Referral[]               @relation("referrals_referrerIdTousers")
  refreshTokens               RefreshToken[]
  securityEvents              SecurityEvent[]
  subscriptionPayments        SubscriptionPayment[]
  travelCompanionsAsCompanion TravelCompanion[]        @relation("travel_companions_companionIdTousers")
  travelCompanionsAsUser      TravelCompanion[]        @relation("travel_companions_userIdTousers")
  travelStats                 TravelStat?
  travelTrips                 TravelTrip[]
  trustMomentsGiven           TrustMoment[]            @relation("trust_moments_giverIdTousers")
  trustMomentsReceived        TrustMoment[]            @relation("trust_moments_receiverIdTousers")
  trustScoreHistories         TrustScoreHistory[]
  userActivities              UserActivity[]
  userBadges                  UserBadge[]
  blockedUsers                UserBlock[]              @relation("user_blocks_blockedIdTousers")
  blockingUsers               UserBlock[]              @relation("user_blocks_blockerIdTousers")
  connectionsInitiated        UserConnection[]         @relation("user_connections_initiatorIdTousers")
  connectionsReceived         UserConnection[]         @relation("user_connections_receiverIdTousers")
  userSetupAnalytics          UserSetupAnalytic[]      @relation("UserSetupAnalytics")
  location                    UserLocation?
  metadata                    UserMetadata?
  paymentMethods              UserPaymentMethod[]
  preferences                 UserPreference?
  privacy                     UserPrivacy?
  profile                     UserProfile?
  security                    UserSecurity?
  sessions                    UserSession[]
  stats                       UserStat?
  subscriptions               UserSubscription[]
  users                       User?                    @relation("usersTousers", fields: [referredById], references: [id])
  other_users                 User[]                   @relation("usersTousers")
  vouchesReceived             Vouch[]                  @relation("vouches_voucheeIdTousers")
  vouchesGiven                Vouch[]                  @relation("vouches_voucherIdTousers")
  accountabilityLogsAsVoucher AccountabilityLog[]      @relation("accountability_logs_voucherIdTousers")
  accountabilityLogsAsVouchee AccountabilityLog[]      @relation("accountability_logs_voucheeIdTousers")
  communityVouchOffers        CommunityVouchOffer[]

  // HomeSurf relations
  homeSurf                UserHomeSurf?
  homeSurfBookingsAsHost  HomeSurfBooking[] @relation("homesurf_host")
  homeSurfBookingsAsGuest HomeSurfBooking[] @relation("homesurf_guest")
  homeSurfReviewsGiven    HomeSurfReview[]  @relation("homesurf_reviews_given")
  homeSurfReviewsReceived HomeSurfReview[]  @relation("homesurf_reviews_received")

  // BerseGuide relations
  berseGuide                   UserBerseGuide?
  berseGuideBookingsAsGuide    BerseGuideBooking[] @relation("berseguide_guide")
  berseGuideBookingsAsTraveler BerseGuideBooking[] @relation("berseguide_traveler")
  berseGuideSessionsGiven      BerseGuideSession[] @relation("guide_sessions_given")
  berseGuideSessionsReceived   BerseGuideSession[] @relation("guide_sessions_received")
  berseGuideReviewsGiven       BerseGuideReview[]  @relation("guide_reviews_given")
  berseGuideReviewsReceived    BerseGuideReview[]  @relation("guide_reviews_received")

  // Card Game relations
  cardGameStreak       CardGameStreak?
  cardGameAchievements UserCardGameAchievement[]

  @@index([createdAt])
  @@index([deletedAt])
  @@index([email])
  @@index([phone])
  @@index([referredById])
  @@index([role])
  @@index([status])
  @@index([totalPoints])
  @@index([trustLevel])
  @@index([trustScore])
  @@index([username])
  @@map("users")
}

model VouchConfig {
  id                             String    @id @default(cuid())
  maxPrimaryVouches              Int       @default(1)
  maxSecondaryVouches            Int       @default(3)
  maxCommunityVouches            Int       @default(2)
  primaryVouchWeight             Float     @default(30.0)
  secondaryVouchWeight           Float     @default(30.0)
  communityVouchWeight           Float     @default(40.0)
  trustMomentsWeight             Float     @default(30.0)
  activityWeight                 Float     @default(30.0)
  cooldownDays                   Int       @default(30)
  minTrustRequired               Float     @default(50.0)
  autoVouchMinEvents             Int       @default(5)
  autoVouchMinMemberDays         Int       @default(90)
  autoVouchRequireZeroNegativity Boolean   @default(true)
  reconnectionCooldownDays       Int       @default(30)
  perTier                        Json?
  effectiveFrom                  DateTime?
  createdAt                      DateTime  @default(now())
  updatedAt                      DateTime  @updatedAt

  @@index([effectiveFrom])
  @@map("vouch_configs")
}

model Vouch {
  id                             String      @id @default(cuid())
  voucherId                      String
  voucheeId                      String
  vouchType                      VouchType   @default(PRIMARY)
  weightPercentage               Float       @default(1.0)
  message                        String?
  status                         VouchStatus @default(PENDING)
  requiresApproval               Boolean     @default(true)
  isCommunityVouch               Boolean     @default(false)
  communityId                    String?
  vouchedByAdminId               String?
  isAutoVouched                  Boolean     @default(false)
  autoVouchCriteria              Json?
  requestedAt                    DateTime    @default(now())
  approvedAt                     DateTime?
  activatedAt                    DateTime?
  revokedAt                      DateTime?
  revokeReason                   String?
  trustImpact                    Float?
  createdAt                      DateTime    @default(now())
  updatedAt                      DateTime    @updatedAt
  users_vouches_voucheeIdTousers User        @relation("vouches_voucheeIdTousers", fields: [voucheeId], references: [id], onDelete: Cascade)
  users_vouches_voucherIdTousers User        @relation("vouches_voucherIdTousers", fields: [voucherId], references: [id], onDelete: Cascade)

  @@unique([voucherId, voucheeId, vouchType])
  @@index([communityId, status])
  @@index([createdAt])
  @@index([isCommunityVouch])
  @@index([voucheeId, status])
  @@index([voucherId, status])
  @@map("vouches")
}

model TrustMoment {
  id                    String         @id @default(cuid())
  connectionId          String
  giverId               String
  receiverId            String
  eventId               String?
  momentType            String         @default("general")
  rating                Int
  feedback              String?
  experienceDescription String?
  tags                  String[]       @default([])
  isPublic              Boolean        @default(true)
  isVerified            Boolean        @default(false)
  verificationSource    String?
  trustImpact           Float          @default(0.0)
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  event                 Event?         @relation(fields: [eventId], references: [id], onDelete: SetNull)
  connection            UserConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  giver                 User           @relation("trust_moments_giverIdTousers", fields: [giverId], references: [id], onDelete: Cascade)
  receiver              User           @relation("trust_moments_receiverIdTousers", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([connectionId, giverId, eventId])
  @@index([eventId])
  @@index([giverId])
  @@index([receiverId])
  @@index([momentType])
  @@index([rating])
  @@index([isPublic])
  @@index([createdAt])
  @@map("trust_moments")
}

model TrustScoreHistory {
  id                String   @id @default(cuid())
  userId            String
  score             Float
  change            Float    @default(0)
  previousScore     Float?
  reason            String?
  component         String?
  relatedEntityType String?
  relatedEntityId   String?
  metadata          Json?
  timestamp         DateTime @default(now())
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp])
  @@index([userId, component])
  @@index([timestamp])
  @@map("trust_score_histories")
}

model AccountabilityLog {
  id                String               @id @default(cuid())
  voucherId         String
  voucheeId         String
  chainId           String?
  impactType        AccountabilityImpact
  impactValue       Float
  description       String?
  relatedEntityType String?
  relatedEntityId   String?
  metadata          Json?
  occurredAt        DateTime             @default(now())
  processedAt       DateTime?
  isProcessed       Boolean              @default(false)
  voucher           User                 @relation("accountability_logs_voucherIdTousers", fields: [voucherId], references: [id], onDelete: Cascade)
  vouchee           User                 @relation("accountability_logs_voucheeIdTousers", fields: [voucheeId], references: [id], onDelete: Cascade)

  @@index([voucherId, isProcessed])
  @@index([voucheeId, occurredAt])
  @@index([impactType, isProcessed])
  @@index([occurredAt])
  @@map("accountability_logs")
}

enum AccountabilityImpact {
  POSITIVE
  NEGATIVE
  NEUTRAL
}

enum AnnouncementPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum AppNoticeType {
  INFO
  WARNING
  ERROR
  SUCCESS
  PROMOTION
  UPDATE
}

enum AppPlatform {
  IOS
  ANDROID
  WEB
}

enum BadgeType {
  // Event & Social Badges
  FIRST_FACE
  CAFE_FRIEND
  SUKAN_SQUAD_MVP
  SOUL_NOURISHER
  HELPERS_HAND
  CONNECTOR // Connect 10+ friends on Berse App
  TOP_FRIEND
  ICEBREAKER
  CERTIFIED_HOST
  STREAK_CHAMP
  LOCAL_GUIDE
  KIND_SOUL
  KNOWLEDGE_SHARER
  ALL_ROUNDER

  // Community Badges
  COMMUNITY_BUILDER // Create or help manage an active community
  COMMUNITY_CHAMPION // Active member in 3+ communities
  MODERATOR_PRO // Became a community moderator
  COMMUNITY_LEADER // Manage a community with 50+ members
  COMMUNITY_ORGANIZER // Hosted 5+ community events

  // Marketplace Badges
  FIRST_SALE // Made your first sale
  TRUSTED_SELLER // 10+ successful transactions as seller
  POWER_BUYER // Purchased 10+ items
  MARKETPLACE_PRO // 50+ transactions (buying + selling)
  FIVE_STAR_SELLER // Maintained 5-star rating with 20+ reviews

  // Vouch System Badges
  VOUCHED // Received your first vouch
  TRUST_BUILDER // Received 3+ vouches
  HIGHLY_VOUCHED // Received 10+ vouches
  VOUCH_GIVER // Given 5+ vouches to others
  COMMUNITY_VOUCHED // Received community vouch

  // Travel & Guide Badges
  GLOBE_TROTTER // Attended trips in 3+ different cities
  ADVENTURE_SEEKER // Attended 5+ trip events
  LOCAL_HOST // Hosted travelers through Homesurf
  SUPER_HOST // 10+ positive Homesurf reviews
  TOUR_GUIDE // Guided 5+ tours through BerseGuide
  EXPLORER // Visit and log 5+ countries in Travel Logbook
  GLOBAL_CITIZEN // Have connections on 5+ continents

  // Engagement Badges
  EARLY_ADOPTER // Joined in the first 1000 users
  DAILY_ACTIVE // Active 30 days in a row
  FEEDBACK_CHAMPION // Left 20+ helpful reviews
  CONVERSATION_STARTER // Started 50+ conversations
  SUPER_RESPONDER // Responded to 100+ messages

  // Achievement Badges
  LEVEL_10 // Reached level 10
  LEVEL_25 // Reached level 25
  LEVEL_50 // Reached level 50
  POINTS_MASTER // Earned 10,000+ points
  PERFECT_PROFILE // Completed 100% of profile

  // Host & Service Badges
  HOST_MASTER // Host 5+ events with good feedback
  SERVICE_STAR // Get 4.5+ star rating across 20+ services

  // Trust & Reputation Badges
  TRUSTED_MEMBER // Reach 80+ trust score
}

enum CommunityRole {
  MEMBER
  MODERATOR
  ADMIN
  OWNER
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELED
  REMOVED
}

enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED
  CLOSED
}

enum EventHostType {
  PERSONAL
  COMMUNITY
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELED
  COMPLETED
}

enum EventParticipantStatus {
  REGISTERED
  CONFIRMED
  CHECKED_IN
  CANCELED
  NO_SHOW
}

enum EventTicketStatus {
  PENDING
  CONFIRMED
  CHECKED_IN
  CANCELED
  REFUNDED
  EXPIRED
}

enum EventType {
  SOCIAL
  SPORTS
  TRIP
  ILM
  CAFE_MEETUP
  VOLUNTEER
  MONTHLY_EVENT
  LOCAL_TRIP
  EDUCATIONAL
  NETWORKING
  WORKSHOP
  CONFERENCE
  CHARITY
  RELIGIOUS
  CULTURAL
  OTHERS
}

enum LegalDocumentType {
  TOS
  PRIVACY_POLICY
  EULA
  COOKIE_POLICY
  COMMUNITY_GUIDELINES
  REFUND_POLICY
  ACCEPTABLE_USE
}

enum ListingStatus {
  DRAFT
  ACTIVE
  SOLD
  EXPIRED
  REMOVED
}

enum MaintenanceStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  DELAYED
}

enum MatchStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

enum MatchType {
  SPORTS
  SOCIAL
  VOLUNTEER
  STUDY
  PROFESSIONAL
  HOBBY
}

enum SwipeAction {
  SKIP
  INTERESTED
}

enum NotificationType {
  EVENT
  MATCH
  POINTS
  MESSAGE
  SYSTEM
  VOUCH
  SERVICE
  MARKETPLACE
  PAYMENT
  SOCIAL
  CONNECTION
  ACHIEVEMENT
  REMINDER
  COMMUNITY
  TRAVEL
}

enum OrderStatus {
  CART
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELED
  REFUNDED
  DISPUTED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
  CANCELED
  REFUNDED
  PARTIALLY_REFUNDED
}

enum PayoutStatus {
  PENDING // Ready for processing/release
  PROCESSING // Being processed by payment gateway
  PAID // Successfully paid out
  RELEASED // Successfully paid out (alias)
  HELD // In escrow, waiting for release conditions
  FROZEN // Frozen due to dispute or investigation
  FAILED // Payout attempt failed
  CANCELED // Payout canceled (refunded to buyer)
}

enum ListingType {
  PRODUCT
  SERVICE
}

enum PaymentMethodType {
  MONEY
  FREE
  TREATS
  BARTER
}

enum PriceStructureType {
  FIXED
  PER_HOUR
  PER_DAY
  PER_SESSION
  PER_PERSON
  PACKAGE
  PROJECT
}

enum ExchangeCategory {
  FOOD
  BOOKS
  ELECTRONICS
  SERVICES
  CLOTHING
  EXPERIENCE
  HOUSEHOLD
  COLLECTIBLES
  OTHER
}

enum ServiceLocationType {
  PROVIDER_LOCATION
  CUSTOMER_LOCATION
  ONLINE
  FLEXIBLE
}

enum ProductCondition {
  NEW
  LIKE_NEW
  GOOD
  FAIR
  POOR
}

enum DurationUnit {
  MINUTES
  HOURS
  DAYS
}

enum FulfillmentStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  READY
  SHIPPED
  DELIVERED
  COMPLETED
  CANCELLED
  REFUNDED
}

enum PricingType {
  PER_HOUR
  PER_DAY
  PER_PERSON
  PER_SESSION
  FIXED
}

enum RedemptionStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ReferralRewardStatus {
  PENDING
  APPROVED
  AWARDED
  CLAIMED
  EXPIRED
  CANCELED
}

enum ServiceType {
  TUTORING
  CONSULTATION
  TRANSPORT
  HOME_SERVICES
  PROFESSIONAL
  WELLNESS
  OTHER
}

enum SubscriptionStatus {
  ACTIVE
  TRIALING
  PAST_DUE
  CANCELED
  EXPIRED
  PAUSED
  INCOMPLETE
}

enum TransactionType {
  EVENT_TICKET
  MARKETPLACE_ORDER
  SUBSCRIPTION
  DONATION
  REFUND
}

enum UserRole {
  GENERAL_USER
  GUIDE
  MODERATOR
  ADMIN
}

enum UserStatus {
  ACTIVE
  DEACTIVATED
  BANNED
  PENDING
}

enum VouchOfferStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

enum VouchStatus {
  PENDING
  APPROVED
  ACTIVE
  REVOKED
  DECLINED
}

enum VouchType {
  PRIMARY
  SECONDARY
  COMMUNITY
}

enum AccommodationType {
  PRIVATE_ROOM // Guest gets a private bedroom
  SHARED_ROOM // Guest shares a room with others
  COUCH // Couch/sofa in common area
  ENTIRE_PLACE // Guest has entire apartment/house
}

enum PaymentType {
  MONEY // Cash or digital payment
  SKILL_TRADE // Exchange skills (teach language, cook, etc.)
  TREAT_ME // Buy me food/drinks (lunch, dinner, groceries, coffee, etc.)
  BERSE_POINTS // Pay with platform points
  FREE // Free, no payment
  NEGOTIABLE // To be discussed
}

enum GuideType {
  FOOD_TOUR // Restaurant hopping, street food, markets
  CULTURAL_TOUR // Museums, temples, historical sites
  NIGHTLIFE // Bars, clubs, entertainment
  HIKING // Nature walks, mountain trails
  CYCLING // Bike tours around city
  PHOTOGRAPHY // Photo spots, photography tips
  SHOPPING // Best stores, markets, malls
  LOCAL_EXPERIENCE // Live like a local
  HISTORICAL_SITES // History-focused tours
  NATURE_WALKS // Parks, gardens, nature
  BAR_HOPPING // Bar crawl
  COFFEE_CRAWL // Best coffee shops
  STREET_ART // Graffiti, murals, art scene
  HIDDEN_GEMS // Off-the-beaten-path spots
  FAMILY_FRIENDLY // Suitable for families with kids
  ADVENTURE_SPORTS // Extreme activities
}

enum HomeSurfBookingStatus {
  PENDING // Initial request sent
  DISCUSSING // Host and guest are messaging
  APPROVED // Host approved the request
  REJECTED // Host declined
  CANCELLED_BY_GUEST // Guest cancelled
  CANCELLED_BY_HOST // Host cancelled
  CHECKED_IN // Guest has checked in
  COMPLETED // Stay is over, ready for reviews
}

enum BerseGuideBookingStatus {
  PENDING // Initial request sent
  DISCUSSING // Guide and traveler are messaging
  APPROVED // Guide approved the request
  REJECTED // Guide declined
  CANCELLED_BY_TRAVELER // Traveler cancelled
  CANCELLED_BY_GUIDE // Guide cancelled
  IN_PROGRESS // Tour is happening now
  COMPLETED // Tour finished, ready for review
}

enum ReviewerRole {
  HOST // Writing review as a host
  GUEST // Writing review as a guest
  GUIDE // Writing review as a guide
  TRAVELER // Writing review as a traveler
}

// ==================== HOMESURF MODELS ====================

model UserHomeSurf {
  userId    String  @id
  isEnabled Boolean @default(false)

  // Basic Info
  title             String // "Cozy apartment in San Francisco"
  description       String // Detailed description
  accommodationType AccommodationType // PRIVATE_ROOM, SHARED_ROOM, COUCH, ENTIRE_PLACE
  maxGuests         Int               @default(1)

  // Amenities & Rules
  amenities  String[] // ["wifi", "kitchen", "parking", "washing_machine", "workspace"]
  houseRules String? // "No smoking, no parties, quiet after 10pm"
  photos     String[] @default([])

  // Multiple Payment Options (user can offer multiple)
  paymentOptions HomeSurfPaymentOption[]

  // Availability
  availabilityNotes String? // "Available weekends mostly", "Need 1 week notice"
  minimumStay       Int? // Minimum nights
  maximumStay       Int? // Maximum nights
  advanceNotice     Int? // Days notice needed before check-in

  // Location
  city         String // For search/discovery
  neighborhood String?
  address      Json? // Private, only shown after approval
  coordinates  Json? // For map display (approximate)

  // Stats & Trust
  responseRate        Float? @default(0) // % of requests responded to
  averageResponseTime Int? // In hours
  totalGuests         Int    @default(0) // Total guests hosted
  rating              Float? @default(0) // Average rating (1-5)
  reviewCount         Int    @default(0)

  // Metadata
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  lastActiveAt DateTime @default(now()) // Last time profile was edited

  // Relations
  user     User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  bookings HomeSurfBooking[]
  reviews  HomeSurfReview[]

  @@index([isEnabled, city])
  @@index([city, isEnabled])
  @@map("user_homesurf")
}

model HomeSurfPaymentOption {
  id          String      @id @default(cuid())
  homeSurfId  String
  paymentType PaymentType // MONEY, SKILL_TRADE, TREAT_ME, BERSE_POINTS, FREE
  amount      Float? // If MONEY, the amount per night
  currency    String?     @default("USD")
  description String? // "Help with gardening 2 hours", "Buy me lunch", "Groceries for the week"
  isPreferred Boolean     @default(false) // Host's preferred option

  homeSurf UserHomeSurf @relation(fields: [homeSurfId], references: [userId], onDelete: Cascade)

  @@index([homeSurfId])
  @@map("homesurf_payment_options")
}

model HomeSurfBooking {
  id      String @id @default(cuid())
  hostId  String
  guestId String

  // Request Details
  checkInDate    DateTime
  checkOutDate   DateTime
  numberOfGuests Int      @default(1)
  message        String? // Guest's introduction/request

  // Status & Timeline
  status HomeSurfBookingStatus @default(PENDING)
  // PENDING  DISCUSSING  APPROVED/REJECTED
  // APPROVED  CHECKED_IN  COMPLETED
  // Can be CANCELLED_BY_GUEST or CANCELLED_BY_HOST at any time

  // Agreed Terms (after discussion via messages)
  agreedPaymentType    PaymentType?
  agreedPaymentAmount  Float?
  agreedPaymentDetails String? // Details of the agreed exchange
  specialRequests      String? // Dietary needs, accessibility, etc.
  checkInInstructions  String? // Provided by host after approval (lockbox code, etc.)

  // Communication
  conversationId String? // Link to message thread

  // Timestamps
  requestedAt        DateTime  @default(now())
  respondedAt        DateTime? // When host first responds
  approvedAt         DateTime?
  checkedInAt        DateTime? // Actual check-in time
  checkedOutAt       DateTime? // Actual check-out time
  completedAt        DateTime? // When both reviews are done
  cancelledAt        DateTime?
  cancellationReason String?

  // Relations
  host         User             @relation("homesurf_host", fields: [hostId], references: [id], onDelete: Cascade)
  guest        User             @relation("homesurf_guest", fields: [guestId], references: [id], onDelete: Cascade)
  homeSurf     UserHomeSurf     @relation(fields: [hostId], references: [userId], onDelete: Cascade, map: "homesurf_booking_homesurf_fkey")
  hostReviews  HomeSurfReview[] @relation("BookingHostReviews")
  guestReviews HomeSurfReview[] @relation("BookingGuestReviews")

  @@index([hostId, status])
  @@index([guestId, status])
  @@index([checkInDate])
  @@index([status])
  @@map("homesurf_bookings")
}

model HomeSurfReview {
  id           String       @id @default(cuid())
  bookingId    String
  reviewerId   String // Who's writing the review
  revieweeId   String // Who's being reviewed
  reviewerRole ReviewerRole // HOST or GUEST

  // Overall Rating
  rating Int // 1-5 stars
  review String? // Written review

  // Specific Ratings (optional, for detailed feedback)
  cleanliness   Int? // For accommodation (guest  host)
  communication Int? // Both directions
  location      Int? // For accommodation (guest  host)
  hospitality   Int? // Host's friendliness (guest  host)
  respect       Int? // Guest's behavior (host  guest)

  // Recommendation
  wouldHostAgain Boolean? // Host's perspective
  wouldStayAgain Boolean? // Guest's perspective

  // Media
  photos   String[] @default([])
  isPublic Boolean  @default(true)

  createdAt DateTime @default(now())

  // Relations
  bookingAsHost  HomeSurfBooking? @relation("BookingHostReviews", fields: [bookingId], references: [id], onDelete: Cascade, map: "homesurf_review_booking_host_fkey")
  bookingAsGuest HomeSurfBooking? @relation("BookingGuestReviews", fields: [bookingId], references: [id], onDelete: Cascade, map: "homesurf_review_booking_guest_fkey")
  reviewer       User             @relation("homesurf_reviews_given", fields: [reviewerId], references: [id], onDelete: Cascade)
  reviewee       User             @relation("homesurf_reviews_received", fields: [revieweeId], references: [id], onDelete: Cascade)
  homeSurf       UserHomeSurf     @relation(fields: [revieweeId], references: [userId], onDelete: Cascade, map: "homesurf_review_homesurf_fkey")

  @@unique([bookingId, reviewerId])
  @@index([revieweeId])
  @@index([reviewerId])
  @@map("homesurf_reviews")
}

// ==================== BERSEGUIDE MODELS ====================

model UserBerseGuide {
  userId    String  @id
  isEnabled Boolean @default(false)

  // Basic Info
  title       String // "Tokyo Food Adventure Guide"
  description String // Full description of what you offer
  tagline     String? // Short catchy line: "Hidden gems & local flavors"

  // Guide Specialties
  guideTypes  GuideType[] // Array of enums (can select multiple)
  customTypes String[] // Additional custom guide types
  languages   String[] // ["English", "Japanese", "Spanish"]

  // Coverage Area
  city           String
  neighborhoods  String[] // ["Shibuya", "Harajuku", "Shinjuku"]
  coverageRadius Int? // km from city center

  // Multiple Payment Options
  paymentOptions BerseGuidePaymentOption[]

  // Logistics
  availabilityNotes String? // "Weekends mostly", "Flexible schedule"
  typicalDuration   Int? // Typical tour hours
  minDuration       Int? // Minimum tour length
  maxDuration       Int? // Maximum tour length
  maxGroupSize      Int     @default(1) // How many people you can guide
  advanceNotice     Int? // Days notice needed

  // Experience
  yearsGuiding    Int? // Years of experience
  totalSessions   Int      @default(0) // Total tours given
  photos          String[] @default([]) // Profile & tour photos
  highlights      String[] // ["Best ramen spots", "Hidden temples", "Rooftop bars"]
  sampleItinerary String? // Sample tour itinerary

  // Stats
  responseRate        Float? @default(0)
  averageResponseTime Int? // Hours
  rating              Float? @default(0)
  reviewCount         Int    @default(0)

  // Metadata
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  lastActiveAt DateTime @default(now())

  // Relations
  user     User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  bookings BerseGuideBooking[]
  reviews  BerseGuideReview[]
  sessions BerseGuideSession[]

  @@index([isEnabled, city])
  @@index([city, isEnabled])
  @@map("user_berseguide")
}

model BerseGuidePaymentOption {
  id           String      @id @default(cuid())
  berseGuideId String
  paymentType  PaymentType // MONEY, SKILL_TRADE, TREAT_ME, BERSE_POINTS, FREE
  amount       Float?
  currency     String?     @default("USD")
  description  String? // "Buy me lunch at a local spot", "Teach me basic photography"
  isPreferred  Boolean     @default(false)

  berseGuide UserBerseGuide @relation(fields: [berseGuideId], references: [userId], onDelete: Cascade)

  @@index([berseGuideId])
  @@map("berseguide_payment_options")
}

model BerseGuideBooking {
  id         String @id @default(cuid())
  guideId    String
  travelerId String

  // Request Details
  preferredDate    DateTime? // Flexible, might change
  alternativeDates DateTime[] @default([])
  preferredTime    String? // "morning", "afternoon", "evening", "flexible"
  duration         Int? // Requested hours
  numberOfPeople   Int        @default(1)
  interests        String[] // ["food", "culture", "nature", "nightlife"]
  specificRequests String? // "Want to see X, avoid Y"
  message          String? // Initial message from traveler

  // Status
  status BerseGuideBookingStatus @default(PENDING)
  // PENDING  DISCUSSING  APPROVED/REJECTED
  // APPROVED  IN_PROGRESS  COMPLETED
  // Can be CANCELLED_BY_TRAVELER or CANCELLED_BY_GUIDE

  // Agreed Terms (after discussion)
  agreedDate           DateTime?
  agreedTime           String?
  agreedDuration       Int?
  agreedPaymentType    PaymentType?
  agreedPaymentAmount  Float?
  agreedPaymentDetails String?
  meetingPoint         String? // "Starbucks at Shibuya Station"
  itinerary            String? // Agreed plan for the tour

  // Communication
  conversationId String?

  // Timestamps
  requestedAt        DateTime  @default(now())
  respondedAt        DateTime?
  approvedAt         DateTime?
  startedAt          DateTime? // When tour actually starts
  completedAt        DateTime?
  cancelledAt        DateTime?
  cancellationReason String?

  // Relations
  guide      User               @relation("berseguide_guide", fields: [guideId], references: [id], onDelete: Cascade)
  traveler   User               @relation("berseguide_traveler", fields: [travelerId], references: [id], onDelete: Cascade)
  berseGuide UserBerseGuide     @relation(fields: [guideId], references: [userId], onDelete: Cascade, map: "berseguide_booking_guide_fkey")
  session    BerseGuideSession?
  review     BerseGuideReview?

  @@index([guideId, status])
  @@index([travelerId, status])
  @@index([agreedDate])
  @@index([status])
  @@map("berseguide_bookings")
}

model BerseGuideSession {
  id         String @id @default(cuid())
  bookingId  String @unique
  guideId    String
  travelerId String

  // Session Details
  date             DateTime // Actual date
  startTime        DateTime // Actual start time
  endTime          DateTime? // Actual end time
  actualDuration   Int? // Minutes (calculated from start/end)
  locationsCovered String[] // ["Tsukiji Market", "Senso-ji Temple", "Shibuya Crossing"]
  photos           String[]  @default([]) // Photos from the tour
  notes            String? // Guide's notes about the session

  // Payment
  paymentType      PaymentType?
  paymentAmount    Float?
  paymentCompleted Boolean      @default(false)

  createdAt DateTime @default(now())

  // Relations
  booking    BerseGuideBooking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  guide      User              @relation("guide_sessions_given", fields: [guideId], references: [id], onDelete: Cascade)
  traveler   User              @relation("guide_sessions_received", fields: [travelerId], references: [id], onDelete: Cascade)
  berseGuide UserBerseGuide    @relation(fields: [guideId], references: [userId], onDelete: Cascade, map: "berseguide_session_guide_fkey")

  @@index([guideId])
  @@index([date])
  @@map("berseguide_sessions")
}

model BerseGuideReview {
  id         String @id @default(cuid())
  bookingId  String @unique
  guideId    String
  travelerId String

  // Overall Rating
  rating Int // 1-5 stars
  review String? // Written review

  // Specific Ratings
  knowledge      Int? // Guide's expertise about area
  communication  Int? // How well they communicated
  friendliness   Int? // Friendliness and hospitality
  value          Int? // Was it worth the payment?
  wouldRecommend Boolean? // Would recommend this guide?

  // Highlights
  highlights String[] // ["Great food spots", "Fun personality", "Lots of history"]
  photos     String[] @default([])
  isPublic   Boolean  @default(true)

  createdAt DateTime @default(now())

  // Relations
  booking    BerseGuideBooking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  guide      User              @relation("guide_reviews_received", fields: [guideId], references: [id], onDelete: Cascade)
  reviewer   User              @relation("guide_reviews_given", fields: [travelerId], references: [id], onDelete: Cascade)
  berseGuide UserBerseGuide    @relation(fields: [guideId], references: [userId], onDelete: Cascade, map: "berseguide_review_guide_fkey")

  @@index([guideId])
  @@index([rating])
  @@map("berseguide_reviews")
}

model PlatformConfig {
  id          String   @id @default(cuid())
  category    String // Config category (TRUST_FORMULA, TRUST_LEVELS, etc.)
  key         String // Specific config key within category
  value       Json // Flexible JSON storage for config data
  description String? // Human-readable description of what this config does
  updatedBy   String? // Admin user ID who last updated this config
  updatedAt   DateTime @updatedAt
  version     Int      @default(1) // Incremented on each update for tracking
  createdAt   DateTime @default(now())

  @@unique([category, key])
  @@index([category])
  @@map("platform_configs")
}

model ConfigHistory {
  id        String   @id @default(cuid())
  configId  String // Reference to PlatformConfig.id
  category  String // Denormalized for easier querying
  key       String // Denormalized for easier querying
  oldValue  Json // Previous configuration value
  newValue  Json // New configuration value
  changedBy String // Admin user ID who made the change
  changedAt DateTime @default(now())
  reason    String? // Optional explanation for the change

  @@index([configId])
  @@index([changedAt])
  @@index([category, key])
  @@map("config_history")
}

// Card Game Streak Tracking
model CardGameStreak {
  id             String   @id @default(cuid())
  userId         String   @unique
  currentStreak  Int      @default(0)
  longestStreak  Int      @default(0)
  lastActiveDate DateTime
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, currentStreak])
  @@map("card_game_streaks")
}

// Card Game Achievement Definitions
model CardGameAchievement {
  id               String                    @id @default(cuid())
  code             String                    @unique // e.g. "first-session", "thoughtful-contributor"
  title            String
  description      String
  icon             String // Emoji or image URL
  criteria         Json // { type: "session_count", value: 1 }
  createdAt        DateTime                  @default(now())
  updatedAt        DateTime                  @updatedAt
  userAchievements UserCardGameAchievement[]

  @@index([code])
  @@map("card_game_achievements")
}

// User's Unlocked Achievements
model UserCardGameAchievement {
  id            String              @id @default(cuid())
  userId        String
  achievementId String
  unlockedAt    DateTime            @default(now())
  user          User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement   CardGameAchievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([userId])
  @@index([achievementId])
  @@index([unlockedAt])
  @@map("user_card_game_achievements")
}
